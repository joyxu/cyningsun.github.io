<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有疑者说</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://www.cyningsun.com/"/>
  <updated>2020-09-06T14:55:46.907Z</updated>
  <id>https://www.cyningsun.com/</id>
  
  <author>
    <name>cyningsun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次 Redis 迁移 —— Key 丢失问题排查</title>
    <link href="https://www.cyningsun.com/09-06-2020/redis-migrate-key-lost.html"/>
    <id>https://www.cyningsun.com/09-06-2020/redis-migrate-key-lost.html</id>
    <published>2020-09-05T16:00:00.000Z</published>
    <updated>2020-09-06T14:55:46.907Z</updated>
    
    <content type="html"><![CDATA[<p>上半年，我们将 Redis集群 从旧机房迁移到了服务所在的新机房，迁移过程碰到了一些常见的方法，也遇到一些Key丢失的问题，因此写文章来记录和总结下。</p><h3 id="迁移清单"><a href="#迁移清单" class="headerlink" title="迁移清单"></a>迁移清单</h3><p>想要平稳顺利的迁移，那么做好准备哦那个工作很重要。最重要的工作就是准备 <a href="/08-02-2020/release-checklist.html">清单</a>。一个合格的数据库迁移一般要包括：步骤、灰度策略、验证措施、回滚方案。</p><ol><li>devops 使用 <code>redis-shake</code> 从旧集群持续同步数据到新集群</li><li>dev 验证新集群功能正常</li><li>devops 确认新旧集群 Key 一致</li><li>dev 开始发布的切换到新集群配置<blockquote><ol><li>按照地区灰度迁移（在东南亚七个地区提供服务，因此可以优先灰度用户量小的地区）</li><li>将服务分为 <strong>无风险</strong>、<strong>低风险</strong>、<strong>高风险</strong>，按照风险等级分组发布和回退</li><li>发布群通知所有人开始发布</li><li>观察服务监控、并验证服务功能</li></ol></blockquote></li><li>devops 确认旧集群流量为0，新集群调用量、监控正常</li></ol><h3 id="个别-Key-同步失败"><a href="#个别-Key-同步失败" class="headerlink" title="个别 Key 同步失败"></a>个别 Key 同步失败</h3><p>第一个问题出现在 <code>步骤3</code>。在数据同步完全正常的情况下，发现个别 Key 没有同步到新集群</p><pre><code class="hljs sh">0       lack_target     xxx_cron_RetryEsStoreTask0       lack_target     xxx_cron_WsCDNStatMonitor0       lack_target     xxx_cron_TaskMonitor0       lack_target     xxx_cron_TxCloudStatMonitor</code></pre><p>以上几个 Key 存在比较明显的特征，即，都是定时任务使用Redis作为分布式锁创建的。该部分比较特殊的地方在于使用 lua 脚本，而同步工具对 lua的支持不太好。</p><h3 id="Redis-集群流量持续不归零"><a href="#Redis-集群流量持续不归零" class="headerlink" title="Redis 集群流量持续不归零"></a>Redis 集群流量持续不归零</h3><p>第二个问题出现在 <code>步骤5</code>，迁移完成之后Redis流程持续不归零，经过捞日志发现，该部分流量来源于监控、扫描检测程序</p><p><img src="/images/redis-migrate-key-lost/redis-monitor.png" alt="redis monitor"></p><h3 id="个别-Key-奇怪丢失"><a href="#个别-Key-奇怪丢失" class="headerlink" title="个别 Key 奇怪丢失"></a>个别 Key 奇怪丢失</h3><p>第三个问题出现在迁移完第一个地区的两天后，在迁移地区的本地运营同学反馈一个问题，少部分 Key 莫名奇怪的丢失</p><pre><code class="hljs sh">2020-03-05 18:01:32 写入key：xxx_balancestatus_2162131362020-03-05 18:06:49 检测到key丢失2020-03-06 18:05:21 再次写入key</code></pre><p>检查了项目代码里，没有删除key的操作，请问能否查下redis数据是否正常，有没有意外丢失key的可能性。以下是我们排查的对话：</p><pre><code class="hljs sh">Devops: xxx_balancestatus_216213136  这个key有设置ttl嘛？Dev： 有，3 天Dev: 相同的key，18:01设置的key（3d过期），18:06丢失了 (提供了日志作为依据)Devops：可能是同步进程挂的时间太长了，源集群过期的key  forward了del命令到新集群Me：你按照删除时间，往前三天看下能否捞到这个用户的写入日志，如果时间对的上，那可以基本上证明是这个原因Dev：2日刚好有一个写入操作Me： 2号到5号，该用户还有写入么Dev: 4号还有一次Me: 4号几点？Dev: 4号 18 点Devops: 4号18点 已经切换集群了, 所以2号写入的key 在老集群, 3天后 过期 forward del命令到新集群</code></pre><p>充足的日志提供了有力的证据把握各个时间点，成功捉虫：Devops 为了确保安全，没有尽快把同步程序关掉，导致该问题</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/redis-migrate-key-lost/interface-timecost.png" alt="migrate result"></p><p>迁移之后，平均耗时有1～2ms的降低，服务迁移有着比较明显的效果。由于两个地方位于同一个城市，说明调用耗时产生的原因跟距离关系不大，猜测跟机房的网络架构关系很大(之前也遇到过，同一地区同样配置服务，有一个机房就是比其他机房调用慢不少)。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/09-06-2020/redis-migrate-key-lost.html">https://www.cyningsun.com/09-06-2020/redis-migrate-key-lost.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上半年，我们将 Redis集群 从旧机房迁移到了服务所在的新机房，迁移过程碰到了一些常见的方法，也遇到一些Key丢失的问题，因此写文章来记录和总结下。&lt;/p&gt;
&lt;h3 id=&quot;迁移清单&quot;&gt;&lt;a href=&quot;#迁移清单&quot; class=&quot;headerlink&quot; title=&quot;迁
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.cyningsun.com/category/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="迁移" scheme="https://www.cyningsun.com/tag/%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>B+树 —— 数据库的灵魂</title>
    <link href="https://www.cyningsun.com/08-25-2020/mysql-bplustree.html"/>
    <id>https://www.cyningsun.com/08-25-2020/mysql-bplustree.html</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>虽然 <code>Nosql</code> 风生水起，关系型数据库在当前的开发中仍然扮演着不可或缺的角色。因此在面试中也会被时常问到，很多问题即使是工作多年的同学仍然会磨棱两可，例如：</p><ol><li>为什么使用B+树，而不是B树作为底层数据结构？</li><li><strong>最左前缀匹配原则</strong> 为什么跟索引中字段顺序相关，而与查询中字段顺序无关？</li><li>Like 查询能够使用索引吗？</li><li>主键为什么最好选择递增的字段？</li></ol><p>很多人把原因归结于没有认真准备。靠记忆死记硬背终归落了下乘，归根结底还是没有把握住<strong>本质</strong>。Mysql的本质是什么？当然是其存储引擎。要想对数据库有本质的认识，了解存储引擎底层的数据结构 B+树 是一堂必修课。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>如果此B+树的阶数是 m+1，则：</p><ul><li>每个节点最多有 m 个 Key 及 m+1 个子节点</li><li>除根节点外，所有节点必须半满（Half-full）</li><li>如果 m 是 偶数，且 m = 2d<ul><li>叶节点半满：至少有 d 个Key</li><li>非叶节点半满：至少有 d 个Key</li></ul></li><li>如果 m 是奇数，且 m = 2d+1<ul><li>叶节点半满：至少有 d+1 个 Key</li><li>非叶节点半满：至少有 d 个Key</li></ul></li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>从根节点开始，检查非叶子节点的索引项，可以使用二分（或线性）搜索进行查找，以找到对应的子节点。沿着树向下遍历，直到到达叶节点</p><blockquote><p><img src="/images/bplustree/bplustree-search.png" alt="bplustree-search"></p><p>根据以上方法查找 15*，可知它不在该树上</p></blockquote><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><ol><li><p>首先，查找要插入的 <code>叶节点 L</code></p></li><li><p>接着把数据项插入这个节点中</p><ul><li>如果没有节点处于违规状态，则处理结束</li><li>否则，均匀的拆分 L 为两个节点（ L和 新节点 L2），使得每个都有最小数目的元素<ul><li>将索引项中间的 key 复制到父节点<strong>（Copy up）</strong></li><li>将指向 L2 的索引项插入到 L 的父节点</li></ul></li></ul></li><li><p>沿树递归向上，继续这个处理直到到达根节点</p><ul><li><p>若要拆分索引节点，需均匀地拆分索引条目，将中间的 key 移动到父节点<strong>（Push up）</strong></p><blockquote><p>与叶节点拆分对比操作不同</p></blockquote></li></ul></li><li><p>如果根节点被分裂，则创建一个新根节点。</p></li></ol><blockquote><p>假设，将  8* 插入到上述 B+ 树，观察在叶节点和非叶节点拆分中如何保证半满的。并注意 Copy up 和 Push up 之间的区别，确保理解其中的原因。</p><p>a) 首先找到的 叶节点 L，并拆分</p><ul><li>将 索引项的 key 5 Copy up</li><li>将 指向 L2 的 索引项指针添加到 L 的 父节点</li></ul><p><img src="/images/bplustree/bplustree-leaf-split.png" alt="bplustree-leaf-split"></p><p>b) key 5 Copy up 到父节点子后，导致非叶节点拆分：</p><ul><li>17 Push up 到 父节点</li></ul><p><img src="/images/bplustree/bplustree-nonleaf-split.png" alt="bplustree-nonleaf-split"></p><p>c）最终根节点被拆分，并导致树高度增加，得到以下B+树</p><p><img src="/images/bplustree/bplustree-insert-end.png" alt="bplustree-insert-end"></p></blockquote><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ol><li>从根节点开始，查找该项归属的 叶节点 L</li><li>删除该项<ul><li>如果叶节点L 多于半满，则处理结束</li><li>如果叶节点L 不足半满的索引项<ul><li>尝试从兄弟节点（与L具有相同父级的相邻节点）借索引项，重新分配。</li><li>如果重新分配失败，则合并 L 和 兄弟节点</li></ul></li></ul></li><li>如果发生合并，则必须从L的父索引项中删除索引项（指向L或兄弟节点的）</li><li>递归此处理直到节点是合法状态，或者到达根节点。</li></ol><blockquote><p>假设，对上述B+树，依次删除 19*、20*、24*</p><p>a) 删除 19*，较为简单，得到</p><p><img src="/images/bplustree/bplustree-delete-leaf.png" alt="bplustree-delete-leaf"></p><p>b) 删除 20*，是通过重新分配完成的。注意中间的 key 是如何 Copy up 的</p><p><img src="/images/bplustree/bplustree-leaf-redistribute.png" alt="bplustree-leaf-redistribute"></p><p>c) 删除 24*，导致与右侧索引项的合并。</p><p><img src="/images/bplustree/bplustree-leaf-must-merge.png" alt="bplustree-leaf-must-merge"></p><p>然后，沿树向上，父节点同样需要与左侧兄弟节点合并，导致根节点的 “pull down” </p><p><img src="/images/bplustree/bplustree-root-pull-down.png" alt="bplustree-root-pull-down"></p></blockquote><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>复合索引的B+树上的键值，就像单key的索引一样。和按字母顺序排列一个句子一样，复合索引中各个字段的顺序很重要。例如，下图为复合索引  (branch_name, balance) 的 B+树</p><blockquote><p><img src="/images/bplustree/bplustree-composite-key-index.jpg" alt="bplustree-composite-key-index"></p><ol><li><p>例如，(Bournemouth, 1000)  小于等于 (Bournemouth, 1000) ，因此它出现在第一个叶节点中； (Bournemouth, 7500) 大于 (Bournemouth, 1000) ，因此它出现在第二个叶节上</p></li><li><p>例如，尽管 (Armagh, 1500) 第二个字段的值大于(Bournemouth, 1000)对应字段的值。字段的顺序意味着 (Bournemouth, 1000) 小于 (Bournemouth, 1000)</p></li></ol></blockquote><p>因此，上面的B+树可以用来搜索 (branch_name) 或 (branch_name, balance) ，而不能搜索 (balance)。例如，balance=2000 出现在B+树的两个路径中。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>由B+树的结构可知，数据记录本身被存于叶子节点上。<strong>就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放</strong>，因此每当有一条新的记录插入时，B+树会根据其主键将其插入适当的节点和位置</p><ol><li><p>如果使用递增的字段作为主键，新增记录就会添加到当前索引节点的后面。<strong>不需要因为插入移动已有数据，因此写入效率很高</strong></p></li><li><p>如果使用随机的字段作为主键，新增记录需要插入到索引的中间位置 。<strong>为了将新记录插到合适位置而移动已经存在的数据。同时频繁的移动、分页操作造成了大量的碎片，降低磁盘读写速度</strong></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>为什么使用B+树，而不是B树作为底层数据结构？</p><blockquote><ol><li>树高较低，磁盘IO次数少</li><li>有利于范围、排序、分组等查询</li></ol></blockquote></li><li><p><strong>最左前缀匹配原则</strong> 为什么跟索引中字段顺序相关，而与查询中字段顺序无关？</p><blockquote><ol><li>因为索引中字段的顺序决定了建立一颗怎样的索引树</li><li>能否使用索引的本质在于，查询语句能否沿树游走</li></ol></blockquote></li><li><p>like 查询能够使用索引吗？</p><blockquote><ol><li>见 <code>问题2</code></li><li><code>%</code> 开头的like语句无法沿树游走，因此无法使用索引</li></ol></blockquote></li><li><p>主键为什么最好选择递增的字段？</p><blockquote><p>详见：<code>聚簇索引</code></p></blockquote></li></ol><p>很多的知识都是串起来的，摸清了B+树，那么对于Mysql的 <a href="/12-02-2015/mysql-index-optimize.html">Explain工具</a> 也就自然能够做到胸有成竹，基本的索引优化自然也就手到擒来。</p><p><strong>参考</strong></p><ol><li><a href="https://web.stanford.edu/class/cs346/2015/" target="_blank" rel="noopener">https://web.stanford.edu/class/cs346/2015/</a></li><li><a href="https://pdfs.semanticscholar.org/0d7b/8b9172a69fa069c9c38b5f01bd37a498563c.pdf" target="_blank" rel="noopener">https://pdfs.semanticscholar.org/0d7b/8b9172a69fa069c9c38b5f01bd37a498563c.pdf</a></li></ol><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/08-25-2020/mysql-bplustree.html">https://www.cyningsun.com/08-25-2020/mysql-bplustree.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;虽然 &lt;code&gt;Nosql&lt;/code&gt; 风生水起，关系型数据库在当前的开发中仍然扮演着不可或缺的角色。因此在面试中也会被时常问到，很多问
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.cyningsun.com/category/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="B+树" scheme="https://www.cyningsun.com/tag/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据库常识课</title>
    <link href="https://www.cyningsun.com/08-18-2020/first-lesson-of-database.html"/>
    <id>https://www.cyningsun.com/08-18-2020/first-lesson-of-database.html</id>
    <published>2020-08-17T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础认知"><a href="#基础认知" class="headerlink" title="基础认知"></a>基础认知</h3><p>传统关系型数据库（一般，指 InnoDB Mysql ）参考指标：</p><ul><li>1TB：如果数据库会膨胀到 TB 级别，需要考虑 MySQL 分库分库。</li><li>1000 万行或 10GB：单表的记录数超过 1000 万行，或单表磁盘空间占用超过 10GB，需要考虑分表<ul><li>每秒 1000 次写入：单节点写入速率超过每秒 1000 次。可以考虑根据业务场景引入 Redis 或消息队列作为写缓冲，实现数据库写操作异步化</li></ul></li></ul><blockquote><p>来源：刘春辉 《Shopee 是如何进行数据库选型的？》</p></blockquote><p>数据库的单机QPS不过几千，显然满足不了互联网业务场景下对高并发的要求。因此，分库分表 + 读写分离成为常态。</p><ul><li>分库，即把一个库分成多个库，部署在多个实例之上。</li><li>读写分析：主库承载写请求，从库承载读请求。由于多数业务场景都是读远多于写，一个主库挂多个从库，可以有效降低对单库的压力。</li></ul><p>如果写请求继续增加（或，数据量增加）达到瓶颈，就继续分库分表；反之，如果读的请求上升就挂更多的从库。</p><h3 id="分表复杂性"><a href="#分表复杂性" class="headerlink" title="分表复杂性"></a>分表复杂性</h3><p>然而线上业务情况往往复杂的多，随着数据量增加、用户量增加，数据库分表（分库，一般按照业务因此问题不大，暂且不表）会逐渐暴漏出以下问题：</p><ul><li><p>分片复杂</p><ul><li><p>容量预估困难</p><ul><li>某单一数据没有考虑分表，随着业务发展需要分表，且分表字段不是已有的ID字段，变更代价高昂</li></ul><blockquote><p>十倍架构设计、百倍数据设计</p></blockquote></li><li><p>Coordinate&amp;Integrity</p><ul><li>以订单为例，业务会按照买家、卖家、订单状态、支付方式等维度筛选数据。若以买家维度分库分表，则卖家维度的查询会变得困难；反之亦然。解决方案一般是以主要查询为维度，分别建立异构索引，不同数据必然存在一致性的难题</li></ul></li><li><p>数据倾斜</p><ul><li>诸如点赞和关注等偏社交类业务数据，按照用户维度分库分表后常出现数据分布不均匀的现象，少数分片的数据量可能远大于其他分片；这些大分片往往也是读写的热点，进而容易成为性能瓶颈。</li></ul><blockquote><p>解决方案：使用大素数取模再分表 可以得到较好的效果</p></blockquote></li></ul></li><li><p>查询复杂</p><ul><li>多分表查询</li><li>多维度维度：见订单部分</li></ul></li></ul><h3 id="存储细分"><a href="#存储细分" class="headerlink" title="存储细分"></a>存储细分</h3><p>由于数据分表可见的复杂性，在实际使用中，随着对分表的疲劳，不同于诸多传统关系型数据库的新兴分布式数据库也越来越多的被使用在生产环境，例如：TiDB</p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/71023604" target="_blank" rel="noopener">TiDB 在知乎万亿量级业务数据下的实践和挑战</a></p></blockquote><p>无论数据库如何多变，了解其类型和原理，才能看穿表象，把握本质，更好的应用到业务的设计之中</p><h4 id="按照应用类型来分"><a href="#按照应用类型来分" class="headerlink" title="按照应用类型来分"></a>按照应用类型来分</h4><ul><li>键值型：ID - Value</li><li>表格型：ID Collection + Time - Value</li><li>关系模型: ID + ID Collection + Time - Value</li></ul><blockquote><p>参考： <a href="https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html#认识资源">认识资源</a></p></blockquote><h4 id="按照存储模型来分"><a href="#按照存储模型来分" class="headerlink" title="按照存储模型来分"></a>按照存储模型来分</h4><ul><li>B-tree：读取友好，数据有序。LIRS算法，将缓冲池分为两级，数据首先进入第一级，如果数据在较短的时间内被访问两次或者以上，则成为热点数据进入第二级，每一级内部还是采用LRU替换算法</li><li>Bitcak：写入友好，数据无序。在内存中存储了主键和value的索引信息，磁盘文件中存储了主键和value的实际内容。需要定期执行合并（Compaction）操作以实现垃圾回收。Bitcask通过索引文件（hint file）来提高重建哈希表的速度</li><li>LSM：写入友好，数据有序。将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘，读取时需要合并磁盘中的历史数据和内存中最近的修改操作，需要定期执行合并（Compaction）操作以实现垃圾回收</li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/08-18-2020/first-lesson-of-database.html">https://www.cyningsun.com/08-18-2020/first-lesson-of-database.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础认知&quot;&gt;&lt;a href=&quot;#基础认知&quot; class=&quot;headerlink&quot; title=&quot;基础认知&quot;&gt;&lt;/a&gt;基础认知&lt;/h3&gt;&lt;p&gt;传统关系型数据库（一般，指 InnoDB Mysql ）参考指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1TB：如果数据库会膨胀到 T
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.cyningsun.com/category/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="基础常识" scheme="https://www.cyningsun.com/tag/%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>如何设计资源标识符？</title>
    <link href="https://www.cyningsun.com/08-09-2020/resouce-id-design.html"/>
    <id>https://www.cyningsun.com/08-09-2020/resouce-id-design.html</id>
    <published>2020-08-08T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.050Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html#认识资源">如何设计 RPC 接口</a> 中讲到一个观点：</p><blockquote><p>资源在用户侧以 <a href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html">hyper media</a> 存在；资源流到服务中以对象来组织；资源落到存储里就变成了<code>id</code> + <code>content</code>。索引 <code>content</code> 的 id，一般又以 <code>单个</code> 和 <code>集合</code> 的形态存在，具体到数据库中，id 以 聚簇索引存在，content 以聚簇索引叶节点存在</p><p>越来越多的产品按照先获取 <code>id</code> 再读取 <code>content</code> 来访问资源</p></blockquote><p>在REST论文中也有类似的描述：</p><blockquote><p>REST 对于信息的核心抽象是<em>资源*。任何能够被命名的信息都能够作为一个资源。资源 *R</em> 是一个随时间变化的成员函数 <em>M<strong>R</strong>(t)*，该函数将时间 *t</em> 映射到等价的一个实体或值的集合，集合中的值可能是<em>资源的表述</em> 和/或 <em>资源的标识符</em>。</p></blockquote><p><img src="https://www.cyningsun.com/images/Data=ID+Content.png" alt="Data=ID+Content"></p><p>其中包含了以下层面的意思：</p><ol><li>服务是围绕资源建立的，服务存在的价值是对资源更新和组织</li><li>每种资源必须依靠 id 标志，内容本身只是为了最终呈现，作为资源的识别， id 才至关重要</li><li>ID 又以  <code>单个</code> 和 <code>集合</code> 形态存在，“集合” 是一种特殊的资源，包含相同类型的子资源列表</li></ol><p>一般的应用中，通常使用资源唯一 ID 标识资源。ID 生成一般依赖数据库递增，或者 <a href="https://www.cyningsun.com/12-26-2018/id-generator.html">分布式ID生成服务</a>。但在大型系统中，一般有很多资源，在使用资源ID标识资源时，通常需要使用特定于资源的元组来标识资源，例如：&lt;群ID、消息ID&gt; 或&lt;公众号ID，消息ID，文章位置&gt;。这会带来以下问题：</p><ul><li>使用者必须记忆匿名元组、顺序</li><li>元组通常难以传递</li><li>通用服务不理解专用的元组</li><li>专用元组限制了 API 设计的灵活性</li></ul><p>针对以上问题，一般来说可以将元组利用一定的机制进行拼接组装，生成一个唯一的ID。最常见的例子是微信公众平台的OpenID：</p><blockquote><p>OpenID = WechatID (用户微信号) &amp; APPID (公众平台ID)（两个数据加密得到的字符串）</p></blockquote><p>然而特定的拼接方式仍然没有解决理解、通用性问题</p><p>理解和通用性问题，其实有比较通用的解决方案。既以<code>名称-值</code> 对的形式，建立自描述（self-descriptive）的标识符。语言描述可能比较难以理解，那么还是以微信公众平台OpenID为例，如果标志符以下面形式组织将会更容易理解：</p><blockquote><p>wechatid=XXX&amp;appid=XXX（加密得到的字符串）</p></blockquote><p>但是以上组织方式引入了一个新的问题，到底该把哪些数据作为生成标识符的一部分呢？答案就是：集合（依据就是开头的片段）。资源可以由 <code>集合 ID</code> 和 <code>资源 ID</code> 组成；如果资源包含子资源，则子资源可以由 <code>父资源</code> 后跟 <code>子资源的 ID</code>。</p><p>示例 1：存储服务具有一组 <code>buckets</code>，其中每个存储分区都有一组 <code>objects</code>：</p><table><thead><tr><th>API 服务名称</th><th>集合 ID</th><th>资源 ID</th><th>集合 ID</th><th>资源 ID</th></tr></thead><tbody><tr><td>//storage.googleapis.com</td><td>/buckets</td><td>/bucket-id</td><td>/objects</td><td>/object-id</td></tr></tbody></table><p>示例 2：电子邮件服务具有一组 <code>users</code>。每个用户都有一个 <code>settings</code> 子资源，而 <code>settings</code> 子资源拥有包括 <code>customFrom</code> 在内的许多其他子资源：</p><table><thead><tr><th>API 服务名称</th><th>集合 ID</th><th>资源 ID</th><th>资源 ID</th><th>资源 ID</th></tr></thead><tbody><tr><td>//mail.googleapis.com</td><td>/users</td><td>/name@example.com</td><td>/settings</td><td>/customFrom</td></tr></tbody></table><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/08-09-2020/resouce-id-design.html">https://www.cyningsun.com/08-09-2020/resouce-id-design.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;a href=&quot;https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html#认识资源&quot;&gt;如何设计 RPC 接口&lt;/a&gt; 中讲到一个观点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;资源在用户侧
      
    
    </summary>
    
    
      <category term="API Design" scheme="https://www.cyningsun.com/category/API-Design/"/>
    
    
      <category term="资源标志符" scheme="https://www.cyningsun.com/tag/%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何持续、正确、安全的发布？</title>
    <link href="https://www.cyningsun.com/08-02-2020/release-checklist.html"/>
    <id>https://www.cyningsun.com/08-02-2020/release-checklist.html</id>
    <published>2020-08-01T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.050Z</updated>
    
    <content type="html"><![CDATA[<p>在一个水平不一、每周例行发布的项目团队，从频繁故障，到故障基本清零——我们如何做到？秘密武器就是：发布清单。</p><p>发布清单为什么可以，先通过一个例子了解一下背后的依据，它就是电影《中国机长》。《中国机长》改编自川航3U8633事件，在执飞重庆到拉萨的过程中，突然出现了副驾驶前挡风玻璃掉落，导致失压、缺氧，副驾驶的半个身体直接飞出了机舱，驾驶舱内设备大量故障，气温低达零下40℃。在如此绝境，机长安全备降成都机场，保证了所有旅客的安全。在电影中可以看到这么一幕，当危险来临时，第二机长就迅速拿出了飞行清单，并根据清单上的提示，配合刘机长平安下降到了两万两千英尺的高度…飞机被誉为全世界最安全的交通工具的背后，是像《中国机长》里的机长和乘务员，以及世上所有航空公司的工作人员在按照清单思维来执行每一项工作任务。</p><p>回过头来再看互联网服务，互联网服务一般会因为以下两种情况出现故障：</p><ol><li>用户或数据增长超过容量</li><li>发布</li></ol><p>不是每个产品都有高速的增长，但是每个产品只要增加新的特性都要进行发布。因此后者导致的故障，往往会远多于前者。很多人都觉得发布是一件很容易的事情，而过于自信。但是这份自信往往是因为忽略了以下难题：</p><ul><li><p>记忆和注意力的谬误</p><blockquote><p>在重压之下，人们特别容易忽视一些单调的例行事项。例如：创建新增特性的数据库表     </p></blockquote></li><li><p>麻痹大意</p><blockquote><ul><li>人们会故意跳过一些明明记得的步骤。人们会一直说“以前从来就没出过这类问题”，直到真的发生了严重后果为止。</li><li>小事难不到人，但是最容易被忽略的就是小事</li></ul></blockquote></li></ul><p>发布需要的从来不是速度，也不只是专注，而是 <strong>持续</strong> <strong>稳定</strong> <strong>正确</strong> <strong>安全</strong> 的把事情做好。其实做到这些并不简单，也不容易。话说够多了，那么具体如何做？</p><ol><li><p>发布群，卷入所有利益相关者</p><blockquote><p>一个人免不了会犯错误，但许多人犯错的可能性或许会变得小一些。集体的智慧，要确保各方面的人员都可以对发布进行评估、say no</p></blockquote></li><li><p>发布流程</p><blockquote><p>1、发布人员 在发布群公布发布清单，宣布发布开始</p><ul><li>相关同学（测试、开发） 需要放下手头事情，关注监控</li></ul><p>2、发布人员 宣布发布完成，相关同学 开始验证</p><p>3、相关同学 宣布验证完成</p><ul><li>相关同学宣布 xx功能正常、监控正常</li></ul><p>4、发布人员 确认所有特性验证完毕，宣布本次发布结束</p></blockquote></li><li><p>发布清单</p><blockquote><p>【发布特性】</p><p>​    xxx</p><p>【影响范围】</p><p>​    xxx</p><p>【发布原因】</p><p>   ​    xxx</p><p>【发布类型】</p><p>​    hotfix / 新特性</p><p>【发布服务】</p><p>​    xxx</p><p>【发布步骤】</p><p>​    xxx</p><p>———————</p><p>以上是发布清单示例，但不限于以上内容。对于复杂、影响较大的发布还可以添加“灰度策略” 、“回滚策略”。</p></blockquote></li></ol><p>在讲述清单的一本书《清单革命》中有一句话讲的很好：请承认人类的不完美，每个人都会犯错，在极端复杂的世界里，我们必须改变观念，因为我们别无选择。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/08-02-2020/release-checklist.html">https://www.cyningsun.com/08-02-2020/release-checklist.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个水平不一、每周例行发布的项目团队，从频繁故障，到故障基本清零——我们如何做到？秘密武器就是：发布清单。&lt;/p&gt;
&lt;p&gt;发布清单为什么可以，先通过一个例子了解一下背后的依据，它就是电影《中国机长》。《中国机长》改编自川航3U8633事件，在执飞重庆到拉萨的过程中，突然出
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何设计 RPC 接口</title>
    <link href="https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html"/>
    <id>https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html</id>
    <published>2020-07-26T16:00:00.000Z</published>
    <updated>2020-09-06T12:57:31.518Z</updated>
    
    <content type="html"><![CDATA[<p>如果说之前清晰知道如何 <a href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html">设计HTTP API</a>  就可以了，那么随着微服务走热，服务越来越多，每个服务都要对外暴漏接口，对如何设计RPC接口有个清晰的认识，变得比以前任何时候都重要。</p><p>虽然设计 RPC 接口很重要，但是却并不容易，经历过多少折腾，才能理解接口那些痛：</p><ul><li><p>莫“名”其妙</p><blockquote><p>读取数据可能会因为数据不一样，分别称为：<code>GetXxx</code>  vs <code>GetXxxLite</code> ，所以 lite 不 lite 有啥不一样？类似的太多太多，关于如何取一个好名字，可以看这里：<a href="https://www.cyningsun.com/07-04-2020/how-to-naming-things.html">《如何代码命名》</a></p></blockquote></li><li><p>接口过多</p><blockquote><p>由于页面需要各式各样的数据，导致查询条件差异很大，很容易出现：</p><ul><li>一个查询条件，一个接口的尴尬</li><li>直接新增接口，但实际上该接口可能已经出现过，只是被隐藏在众多接口里</li></ul></blockquote></li><li><p>难以扩展</p><blockquote><p>面向需求设计接口，不进行任何抽象，导致接口难以扩展</p></blockquote></li></ul><p>三者就像追命绳索，一环套一环，环环相扣，最终将服务带入墓地。</p><h3 id="认识复杂性"><a href="#认识复杂性" class="headerlink" title="认识复杂性"></a>认识复杂性</h3><p>举个例子，当从DB表读取表数据时，可以按照以下三种维度读取数据：</p><ol><li><p>DB的维度，允许表之间 join，即操作复合数据</p></li><li><p>表的维度，允许且只允许全部操作一条数据的所有字段</p></li><li><p>字段的维度，允许接口操作表的部分字段。</p></li></ol><p>假设数据库 <code>d</code> 有 <code>t</code>  张表，平均每个表有 <code>f</code> 个字段，每种数据有 <code>n</code> 种操作。则:</p><ul><li>第一种方案，有 <code>n * t!</code> 个接口；</li><li>第二种方案，有 <code>n * t</code> 个接口；</li><li>第三种方案，有 <code>n * t * f!</code> 个接口</li><li>没有方案，则有 <code>n * t! * f! * n</code> 个接口</li></ul><p>聪明的你会选择哪一种方案，你的依据又是什么？想弄清楚这些，就需要继续往下看</p><h3 id="认识资源"><a href="#认识资源" class="headerlink" title="认识资源"></a>认识资源</h3><p>看接口先看资源，所有的接口都是为了操作资源。对资源了解多深刻，也就大概限制了对接口认识多深刻。</p><p>资源在用户侧以  <a href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html">hyper media</a>  存在；资源流到服务中以对象来组织；资源落到存储里就变成了<code>id</code> + <code>content</code>。索引 <code>content</code> 的 id，一般又以 <code>单个</code> 和 <code>集合</code> 的形态存在，具体到数据库中，id 以 聚簇索引存在，content 以聚簇索引叶节点存在</p><p><img src="/images/Data=ID+Content.png" alt="Data=ID+Content"></p><p>越来越多的产品按照先获取 <code>id</code> 再读取 <code>content</code> 来访问资源，之前是搜索引擎，现在是各式各样的内容推荐</p><h3 id="认识操作"><a href="#认识操作" class="headerlink" title="认识操作"></a>认识操作</h3><p>有了对数据的基本认识，对数据的操作无非是：增、删、改、查（包括：ID / 内容列表查询、根据 ID 批量查询内容）</p><p>再加上 80 / 20 原则，为 80%的请求量 设计高性能语义清晰简洁的接口；为 20% 的请求量，引入 <a href="https://www.cnblogs.com/youring2/p/Specification-Pattern.html" target="_blank" rel="noopener">规约模式（Specification-Pattern）</a>，设计扩展性更强的接口；将复杂的查询，变化为 <code>id collection</code>（搜索引擎） +  <code>content</code> （批量查询接口）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了以上这些认知，那么如何为服务设计收敛的接口，也就不再是个问题。</p><br/><h4 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h4><p>请为以下需求设计一套查询的API接口</p><p><strong>主播侧需求</strong></p><p>当主播点开直播直播入口时</p><ul><li>如果有未开始的直播，则进行直播设置；</li><li>如果有进行中的直播，则直接进入该场直播；</li><li>如果没有进行中的直播<ul><li>第一次直播，则创建一场新的直播</li><li>第一场之外的直播，则使用上一场直播的设置，创建一场新的未开始的直播。</li></ul></li></ul><p><strong>用户侧</strong></p><p>当用户点开直播间时</p><ul><li>获取该直播的所有信息，包括：<ul><li>主播信息</li><li>直播信息</li><li>是否关注该主播</li><li>在线人数</li><li>点赞数</li><li>…</li></ul></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html">https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果说之前清晰知道如何 &lt;a href=&quot;https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html&quot;&gt;设计HTTP API&lt;/a&gt;  就可以了，那么随着微服务走热，服务越来越多，每个服务都要对外暴漏
      
    
    </summary>
    
    
      <category term="API Design" scheme="https://www.cyningsun.com/category/API-Design/"/>
    
    
      <category term="RPC" scheme="https://www.cyningsun.com/tag/RPC/"/>
    
  </entry>
  
  <entry>
    <title>你不了解的软件开发过程</title>
    <link href="https://www.cyningsun.com/07-22-2020/software-development-methodology.html"/>
    <id>https://www.cyningsun.com/07-22-2020/software-development-methodology.html</id>
    <published>2020-07-21T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.049Z</updated>
    
    <content type="html"><![CDATA[<p>中国 IT 从业人员中对软件研发过程有系统认识的少之又少，甚至在工作中遇到的科班出身的研发同学同样不例外。相反，大家对于追求热点概念（例如：DDD，领域驱动设计）倒是不遗余力，满怀热情。</p><p>软件开发刚开始的时候，并没有很好的经验或思想来指导项目研发。从研发的各种名词中可以看出来，软件行业从建筑行业借鉴了许多经验。</p><ul><li><p>建筑行业涉及到不同角色协作：设计师、开发商（工人、电工和水暖工）、质量监理、等等。</p><blockquote><p>软件工程类似的角色：产品经理、研发（后端、前端、客户端）、测试、QA</p></blockquote></li><li><p>建筑行业遵循的流程：把端到端的项目分成不同的阶段，每个流程阶段由不同角色负责</p></li></ul><p>每个阶段赋予角色的做法，有利于充分利用成本高昂的人力资源。在借鉴的基础的产生了第一个标准的软件开发流程</p><p><img src="/images/software-development-methodology/Waterfall.jpeg" alt="Waterfall"></p><p>事实上，如同力学三大定律为物理学奠基一样，瀑布模型在软件行业的地位同样不可动摇。虽然随着历史的车轮滚滚向前，软件研发方法论的研究重点从瀑布模型的 “流程”，过渡到以交付速度和成功率为目标的敏捷开发、持续集成、持续交付、持续部署。但研发过程的核心步骤从未改变：分析、设计、开发</p><p><img src="/images/software-development-methodology/Evolution-of-Software-Delivery.png" alt="Evolution-of-Software-Delivery"></p><p>然而，不幸的是，因为追求交付速度、成功率，国内研发不仅丢掉了瀑布模型，也丢掉了核心过程。太多的研发以敏捷为理论核武，把设计完全抛掉，更遑论分析。如果系统确实太过复杂，抑或领导要求，那就装模作样加入一个设计阶段，设计一个看起来能够跑的通的架构。一旦软件进入实现阶段，所有的设计文档就被雪藏起来吃灰。</p><p>重视开发多于设计，不知分析为何物。架构凭经验和感觉，就像无根之水，即使再美也经不起业务变化和迭代的侵蚀，最终走向腐朽。最后不得不亮出终极武器：重构（其实，是“重做”）。</p><p>意识到需要做分析、设计，到知道如何做分析设计，中间有着不小的鸿沟。软件开发不是玄学，有着系统的方法论，以及完善的表达工具。需求分析从业务开始，层层剥开，直至实现。如果把软件想象成建筑，那么各种图就是从某一个特定的视角（viewpoint）表达软件的设计图纸，因此RUP C4+1 称之为 <code>View model</code> 也大抵表达该含义吧。选择合适的图表述，把软件表述清楚也能体现出工程人员的软件设计能力。</p><p><strong>各个层级的分析对象</strong><br><img src="/images/software-development-methodology/business-analyze.png" alt="business-analyze"></p><p><strong>各分析阶段用于表达的图</strong><br><img src="/images/software-development-methodology/RUP.jpg" alt="RUP"></p><p>具体使用细节，不再使用例子详细描述，可以参考：</p><ul><li>Microsoft: <a href="https://docs.microsoft.com/en-gb/visualstudio/modeling/analyze-and-model-your-architecture?view=vs-2015" target="_blank" rel="noopener">Analyze and model your architecture</a></li><li>IBM:<a href="https://www.ibm.com/developerworks/cn/rational/define-application-architecture-rational-software-architect-1/index.html" target="_blank" rel="noopener">利用Rational Software Architect 定义应用程序架构 第一部分</a>、<a href="https://www.ibm.com/developerworks/cn/rational/define-application-architecture-rational-software-architect-2/index.html" target="_blank" rel="noopener">利用Rational Software Architect 定义应用程序架构 第二部分</a></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/07-22-2020/software-development-methodology.html">https://www.cyningsun.com/07-22-2020/software-development-methodology.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中国 IT 从业人员中对软件研发过程有系统认识的少之又少，甚至在工作中遇到的科班出身的研发同学同样不例外。相反，大家对于追求热点概念（例如：DDD，领域驱动设计）倒是不遗余力，满怀热情。&lt;/p&gt;
&lt;p&gt;软件开发刚开始的时候，并没有很好的经验或思想来指导项目研发。从研发的各种
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何代码命名</title>
    <link href="https://www.cyningsun.com/07-04-2020/how-to-naming-things.html"/>
    <id>https://www.cyningsun.com/07-04-2020/how-to-naming-things.html</id>
    <published>2020-07-03T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.049Z</updated>
    
    <content type="html"><![CDATA[<br/><p>There are only two hard things in Computer Science: cache invalidation and naming things.         —— Phil Karlton</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发人员习惯性的对设计、架构、微服务夸夸其谈，却很少关注设计、架构如何完完整整的落地到代码本身。架构和设计固然重要，代码并非不重要。正如 <code>Robert C.Martin</code> 所言：“<strong>代码即设计</strong>”。透过好的代码，就能看到其背后精美的设计。</p><p>好的代码，第一步是为每一个类、函数、变量起一个好的名字。可惜的是，大多数人对于如何起一个好名字不得其法。毕竟严格上来说，命名并非计算机科学的范畴。好的命名一个词就可以简单、形象、直观表明其功用甚至原理，例如：</p><ul><li><p>SYN <strong>flood</strong>：洪水一样的SYN请求</p></li><li><p><strong>Pipeline</strong>：管道一样传输数据、依次且单向</p></li></ul><p><img src="/images/design-thinking-process.png" alt="design-thinking-process"></p><p>以上还只是问题解决域，还不是最难的。最难的是，在实际研发中，还要面对问题分析域。如果你的思路结构、层次不清晰，抽象出的各种状态不正交，相互重叠，交差，此时再想起出比较好的名字，则回天乏术；如果你不知道一个事物应该叫什么，你就不可能知道它是什么（<a href="https://www.oreilly.com/library/view/97-things-every/9780596800611/ch76.html" target="_blank" rel="noopener">A Rose by Any Other Name Will End Up As a Cabbage</a>），所以命名的过程也是整理思路的过程。</p><p>根据过往的经验总结，可以将命名分为三个Level，前两个 Level 覆盖 Solution Space 的困境，最后一个 Level 覆盖 Problem Space 的困境</p><ul><li>Level 1：坏味道，嗅出坏味道才能意识到需要改变</li><li>Level 2：命名技巧，一些简单的命名技巧，明白有哪些渠道可以改进</li><li>Level 3：领域语言，命名的道，命名是可以系统化的从业务过渡到研发。</li></ul><h3 id="Level-1-坏味道"><a href="#Level-1-坏味道" class="headerlink" title="Level 1: 坏味道"></a>Level 1: 坏味道</h3><ul><li><p>无意义的命名</p><blockquote><p> i.e. <code>data</code>、<code>info</code>、<code>record</code></p></blockquote></li><li><p>抽象的命名</p><blockquote><p>i.e. <code>data</code> 、<code>object</code>、<code>helper</code>、<code>tool</code>、<code>manager</code>、 <code>processor</code>、<code>handler</code>、<code>maker</code>、<code>util</code>、<code>conf</code>、<code>thing</code>、<code>info</code>、<code>amount</code>、<code>details</code>、<code>do</code>、<code>execute</code>、<code>perform</code>、<code>operate</code>、<code>manage</code>、<code>handle</code></p><p>不够精确，毫无疑问，你确实命名了数据和对象，但即使没有此模糊的名称你也早知道的。将 <code>data</code> 重命名为更具描述性的名称，以标识数据</p></blockquote></li><li><p>简称</p><blockquote><p>i.e. <code>mod</code></p><p><code>mod</code> 像是某个单词的简称，你可能无法确认到底是 <code>mode</code> 或 <code>module</code> </p></blockquote></li><li><p>含糊</p><blockquote><p>i.e. <code>Manager</code> </p><p>命名模糊，谁知道经理到底是干什么的？可以更有意义的替代方案，如：牧民（<strong>Herder</strong>）、主管（<strong>Supervisor</strong>）、策划人（<strong>Planner</strong>）、建筑商（<strong>builder</strong>）</p></blockquote></li><li><p>多个单词</p><blockquote><p>i.e. <code>company_person</code> 代表公司人员</p><p>重命名 <code>company_person</code> 为 <code>staff</code> 更为合适，或者更新一步 <code>employee</code>  或  <code>director</code></p></blockquote></li><li><p>被动语态</p><blockquote><p>i.e. <code>PlanEvents</code> </p><p>重命名 <code>PlanEvents</code> 为主动语 <code>EventPlanner</code> 更好，或者更进一步 <code>Scheduler</code></p></blockquote></li></ul><h3 id="Level-2-命名技巧"><a href="#Level-2-命名技巧" class="headerlink" title="Level 2: 命名技巧"></a>Level 2: 命名技巧</h3><h4 id="增加词汇量"><a href="#增加词汇量" class="headerlink" title="增加词汇量"></a>增加词汇量</h4><blockquote><p>命名只是写作的一部分，主要是词汇。你可能还记得学习外语的一部分就是学习词汇。不用学外语是利弊并存之事。</p></blockquote><ul><li>阅读开源、基础库代码<ul><li>例如：Linux 内核、C++ STL 库 等等</li></ul></li><li>查找业务关联概念<ul><li>例如，库存单位：<code>sku</code> ( Stock Keeping Unit )；搜索简称：<code>qv</code> (Query View Count)</li></ul></li></ul><h4 id="更好的命名方法"><a href="#更好的命名方法" class="headerlink" title="更好的命名方法"></a>更好的命名方法</h4><ul><li><p>遵从惯例、标准</p><blockquote><p>不要使用<code>identifier</code>，而是使用业界惯例 <code>id</code>  作为唯一标识命名。类似的：</p><ul><li><code>ptr</code> 为<code>pointer</code>的缩写；</li><li><code>i</code>、<code>j</code>、<code>k</code> 常常是完美的循环计数变量命名。</li><li><code>size</code>、 <code>capacity</code>、<code>resize</code>、<code>reserve</code>、<code>push</code>、<code>pop</code>、<code>top</code>、<code>back</code>，作为容器的接口，久经考验。要自定义容器不应该使用 <code>GetSize</code> 等命名。</li></ul></blockquote></li><li><p>遵从约束</p><ul><li>语言约束：例如，Go 语言 使用 <code>驼峰</code> 风格，代码中就不要使用C语言的 <code>大写下划线连词</code> 风格</li><li>团队约束：对同一个概念，团队内已经有对应的称呼，应该遵从，而是不是任性夹带私货，例如：直播中（<code>ongoing</code> vs <code>living</code>），已经命名为 <code>ongoing</code> ，要么替换为 <code>living</code>；就全部替换掉，要么继续使用 <code>ongoing</code>，虽然后者更确切。</li><li>框架约束：使用 <a href="https://github.com/Shopify/sarama" target="_blank" rel="noopener">Shopify/sarama</a> 作为 kafka 的 客户端就应该使用<code>Consumer</code>、<code>ConsumerGroup</code>、<code>ConsumerGroupHandler</code>，命名三个层级，而不是自撰 三个层级：<code>Dao</code>、<code>Consumer</code>、<code>Processor</code> </li></ul></li><li><p>对齐、对称</p><blockquote><p>对齐: Golang 标准库包名，httptest、httputil、httptrace</p><p>对称：典型的对称，<code>producer</code>/<code>consumer</code>、<code>begin</code>/<code>end</code>、<code>create</code>/<code>destory</code>、<code>destination</code>/<code>source</code>、<code>get</code>/<code>release</code>、<code>increment</code>/<code>decrement</code>、<code>insert</code>/<code>delete</code>、<code>next</code>/<code>previous</code>、<code>old</code>/<code>new</code>、<code>old</code>/<code>new</code>、<code>open</code>/<code>close</code>、<code>put</code>/<code>get</code>、<code>show</code>/<code>hide</code>、<code>start</code>/<code>stop</code>、<code>target</code>/<code>source</code>、</p></blockquote></li></ul><h3 id="Level-3-领域语言（Domain-language）"><a href="#Level-3-领域语言（Domain-language）" class="headerlink" title="Level 3: 领域语言（Domain language）"></a>Level 3: 领域语言（Domain language）</h3><p>人对名字的反应是潜意识的…所以如果对一个名字有疑惑，可能很难确切地表达原因。我们的设计系统命名应该符合预期。… 但是谁的期望？所有利益相关者，系统的利益相关者，包括但不限于：</p><ul><li>产品经理</li><li>开发（前端、后端、客户端）</li><li>测试</li><li>用户</li></ul><p>代码应该自动使用与业务或领取模型相同的名称。例如，如果一个旅游企业使用 “<strong>venue</strong>” 作为咖啡馆、酒店和旅游景点的通用名称，那么在代码中使用 “<strong>place</strong>” 是一个坏主意</p><blockquote><ul><li>其一，因为使用两种不同的语言，使得沟通变得更复杂</li><li>其二，如果一个词汇，产品经理和用户等不理解软件开发同学的都能直观的理解，那么此命名将是一个好的名字</li><li>其三，将代码命名与领域模型关联起来，所有命名跟业务是契合的</li><li>其四，随着需求迭代，打磨领域模型的同时，可以保证命名随之重构符合语义，保持<strong>常新</strong></li></ul></blockquote><p>使用领域语言统一开发流程，可以从根本上解释命名来源以及合理性。相比一般的技巧，是系统的有理论支撑的。如果技巧是工程派的产出，那么领域语言指导命名就像是学院派的产出。</p><p>具体如何在项目中实施DDD，后续详解。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/07-04-2020/how-to-naming-things.html">https://www.cyningsun.com/07-04-2020/how-to-naming-things.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;br/&gt;

&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things.         —— Phil Karlton&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>REST API 设计规范</title>
    <link href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html"/>
    <id>https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html</id>
    <published>2020-06-28T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.049Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中往往会需要确定一个好的API风格，到底有哪些风格可以参考，API Style 的细节要点有哪些呢？</p><h3 id="Http-API-Style-有哪些？"><a href="#Http-API-Style-有哪些？" class="headerlink" title="Http API Style 有哪些？"></a>Http API Style 有哪些？</h3><ul><li>SOAP：tend to be centered around operations that are usually use-case specific and specialized. </li><li>REST：centered around business (data) entities exposed as resources that are identified via URIs and can be manipulated via standardized CRUD-like methods using different representations, and hypermedia</li><li>GraphQL：a query language for APIs and a runtime for fulfilling those queries with your existing data</li></ul><p>SOAP 风格（严格来说，算不上风格）最早于1998年由微软提出；REST 风格于2000年 由 Roy Thomas Fielding 论文中提出；GraphQL 于2015年由 Facebook 提出；</p><ul><li>SOAP vs REST</li></ul><blockquote><p> 如果要轻松、快速地完成API设计，SOAP 风格的API就足够了。毕竟REST有时很难做到，尤其是在一开始。但随着时间的推移，使用RESET 风格的API，服务器端的演进变得更容易，客户机对变化的适应能力也更强。</p></blockquote><ul><li><p>REST vs GraphQL</p><blockquote><p>REST 限于其历史背景，对于 <code>查询</code> 操作一些细节并没有太多描述，随着互联网的发展，查询的复杂度越来越高，而 GraphQL 是一个很好的补充。</p></blockquote></li></ul><p>在业界有将近70%的API是REST-like的风格，其中当然就包括谷歌、微软等行业巨头，REST 差不多已经成为了事实上的标准，了解、用好 REST 十分必要。</p><h3 id="REST-是什么？"><a href="#REST-是什么？" class="headerlink" title="REST 是什么？"></a>REST 是什么？</h3><p>REST，全称是 Resource Representational State Transfer：通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分解开来：</p><ul><li>Resource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等；</li><li>Representational：某种表现形式，比如用JSON，XML，JPEG等；</li><li>State Transfer：状态变化。通过HTTP动词实现。</li></ul><h4 id="资源模型"><a href="#资源模型" class="headerlink" title="资源模型"></a>资源模型</h4><p>资源是具有类型、数据、与其他资源关系、以及一组对其进行操作的方法的对象。</p><p><img src="/images/restful-concepts.png" alt="_images/concepts.png"></p><h4 id="Richardson成熟度模型"><a href="#Richardson成熟度模型" class="headerlink" title="Richardson成熟度模型"></a>Richardson成熟度模型</h4><h5 id="Level-0"><a href="#Level-0" class="headerlink" title="Level 0"></a>Level 0</h5><p>不使用任何URI，HTTP方法和HATEOAS功能。</p><p>该模型的出发点是使用HTTP作为远程交互的传输系统，但不使用Web的任何机制。基本上就是使用HTTP作为你远程交互机中的隧道机制，通常基于“远程过程调用“（RPC，<a href="http://www.eaipatterns.com/EncapsulatedSynchronousIntegration.html" target="_blank" rel="noopener">Remote Procedure Invocation</a> ）。</p><h5 id="Level-1-Resources"><a href="#Level-1-Resources" class="headerlink" title="Level 1 - Resources"></a>Level 1 - Resources</h5><p><strong>使用</strong> URI、HTTP方法、HATEOAS中的<strong>URI</strong>。</p><p>迈向REST的第一步就是引入资源的概念。接下来，我们所要讨论的是各个资源，而不是将所有请求发送到单一的服务端点。每个资源都由唯一的URI单独标识</p><h5 id="Level-2-HTTP-Verbs"><a href="#Level-2-HTTP-Verbs" class="headerlink" title="Level 2 - HTTP Verbs"></a>Level 2 - HTTP Verbs</h5><p><strong>使用</strong> URI、HTTP方法、HATEOAS中<strong>的URI和HTTP</strong>。</p><p>支持每个公开资源上的几个HTTP谓词 - 创建，读取，更新和删除（CRUD）服务。通常代表业务实体的资源状态可以通过网络进行操作。</p><h5 id="Level-3-Hypermedia-Controls"><a href="#Level-3-Hypermedia-Controls" class="headerlink" title="Level 3 - Hypermedia Controls"></a>Level 3 - Hypermedia Controls</h5><p><strong>使用所有三个，即URI，HTTP和HATEOAS</strong>。</p><p>超媒体控制的关键在于它告诉我们下一步我们可以做什么，以及操作所需资源的URI。与我们必须提前知道在哪里创建预约请求不同（Level2中），在响应中的 HATEOAS 告诉了我们下一步该如何做，以完成应用程序状态转换。</p><h3 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h3><p>REST 本身不是标准，只是一种风格。因此只要遵从该风格，都是OK的。然而，除此之外我们逃不开使用中遇到的很多问题，最典型的问题，如下：</p><ul><li>Error Handling</li><li>Sorting</li><li>Pagination</li><li>versioning</li><li>filtering</li><li>Long running</li><li>Sub-collection</li><li>Action(i.e. Batch Operation)</li></ul><h4 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h4><p>详见：<a href="https://www.cyningsun.com/06-07-2020/unified-error-handling.html">跨服务错误处理</a></p><h4 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h4><p>如果 API 方法允许客户端指定列表结果的排序顺序，则请求消息<strong>应该</strong>包含一个字段：</p><pre><code class="hljs go"><span class="hljs-keyword">string</span> order_by = ...;</code></pre><blockquote><p><strong>说明</strong>：语法中的冗余空格字符是无关紧要的。<code>&quot;foo,bar desc&quot;</code> 和 <code>&quot; foo , bar desc &quot;</code> 是等效的。</p></blockquote><p>字符串值<strong>应该</strong>遵循 SQL 语法：逗号分隔的字段列表。例如：<code>&quot;foo,bar&quot;</code>。默认排序顺序为升序。要将字段指定为降序，<strong>应该</strong>将后缀 <code>&quot; desc&quot;</code> 附加到字段名称中。例如：<code>&quot;foo desc,bar&quot;</code>。</p><h4 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h4><ul><li>可列表集合<strong>应该</strong>支持分页，即使结果通常很小。</li></ul><blockquote><p><strong>说明</strong>：如果某个 API 从一开始就不支持分页，稍后再支持它就比较麻烦，因为添加分页会破坏 API 的行为。 不知道 API 正在使用分页的客户端可能会错误地认为他们收到了完整的结果，而实际上只收到了第一页。</p></blockquote><ul><li><p>翻页方式</p><table><thead><tr><th>后台存储</th><th>Request</th><th>Response</th></tr></thead><tbody><tr><td>搜索引擎</td><td>{    <br />“page_num”: 1,   // 页码从 1 开始<br/><br/>     “page_size”: 10<br/><br/>}</td><td>{  <br/>“code”: 0,  <br/>“msg”: “”,  <br/>“data”: {<br/><br/>“total_cnt”: 100,<br/><br/>“items”: []<br/><br/>}  <br/>}</td></tr><tr><td>数据库</td><td>{<br/><br/>     “last_id”: 1,   //  第一页，默认传0<br/><br/>     “page_size”: 10<br/><br/>}</td><td>{<br/>“code”: 0,<br/>“msg”: “”,<br/>“data”: {<br/><br/>     “items”: [],<br/><br/>     “next_id”: 10   // 下一页放到last_id的值<br/><br/>}<br/>}</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></li></ul><h4 id="Versioning"><a href="#Versioning" class="headerlink" title="Versioning"></a>Versioning</h4><h5 id="业界方案"><a href="#业界方案" class="headerlink" title="业界方案"></a>业界方案</h5><ul><li><p>无版本控制<br>这是最简单的方法，它对于一些内部 API 来说可能是可以接受的。 重大变化可以表示为新资源或新链接。 向现有资源添加内容可能不会带来重大更改，因为不希望看到此内容的客户端应用程序将忽略它。</p><pre><code class="hljs http"><span class="hljs-attribute">https://adventure-works.com/customers/3</span></code></pre></li><li><p>URI 版本控制<br>每次修改 Web API 或更改资源的架构时，向每个资源的 URI 添加版本号。 以前存在的 URI 应像以前一样继续运行，并返回符合原始架构的资源。</p><pre><code class="hljs http"><span class="hljs-attribute">https://adventure-works.com/v2/customers/3</span></code></pre></li><li><p>查询字符串版本控制<br>不是提供多个 URI，而是可以通过在追加到 HTTP 请求后面的查询字符串中使用参数来指定资源的版本，例如</p><pre><code class="hljs http">https://adventure-works.com/customers/3?version=2</code></pre><blockquote><p><strong>注意：</strong>某些较旧的 Web 浏览器和 Web 代理不会缓存在 URI 中包含查询字符串的请求的响应。 这可能会降低使用 Web API 并在此类 Web 浏览器中运行的 Web 应用程序的性能。 </p></blockquote></li><li><p>标头版本控制<br>  不是追加版本号作为查询字符串参数，而是可以实现指示资源的版本的自定义标头。 此方法需要客户端应用程序将相应标头添加到所有请求，虽然如果省略了版本标头，处理客户端请求的代码可以使用默认值（版本 1）。 下面的示例使用了名为 Custom-Header 的自定义标头**。 此标头的值指示 Web API 的版本。</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">https://adventure-works.com/customers/3</span> HTTP/1.1<span class="hljs-attribute">Custom-Header</span>: api-version=1</code></pre></li><li><p>无版本控制：在更改RESTful API时，请以兼容的方式进行更改，并避免生成其他API版本。</p><blockquote><p><strong>说明</strong>：多个版本会使理解、测试、维护、发展、操作和发布我们的系统变得非常复杂。</p></blockquote></li></ul><p>在更改RESTful api时，请以兼容的方式进行更改，并避免生成其他API版本。多个版本可能会显著地复杂化查看、测试、维护、发展、运营和发布系统（<a href="http://martinfowler.com/articles/enterpriseREST.html" target="_blank" rel="noopener">补充阅读</a>)。如果无法以兼容的方式更改API，请使用这三种方式：</p><ul><li>在旧资源变体的基础上创建新资源（变量）</li><li>创建一个新的服务端点-即一个具有新API的新应用程序（使用新域名）</li><li>在微服务中创建一个新的API版本，该版本支持与旧API同时支持</li></ul><h5 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h5><p>在参数过滤时通常会为参数值定义数据格式。为了在所有 API 中提供一致的开发者体验并减少学习曲线，API 设计人员<strong>必须</strong>使用以下<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F#%E7%BA%A6%E5%AE%9A" target="_blank" rel="noopener">扩展巴科斯范式</a>（Extended Backus-Naur Form，简写为“EBNF”）语法的变体来定义这样的语法：</p><pre><code class="hljs javascript">Production  = name <span class="hljs-string">"="</span> [ Expression ] <span class="hljs-string">";"</span> ;Expression  = Alternative &#123; <span class="hljs-string">"|"</span> Alternative &#125; ;Alternative = Term &#123; Term &#125; ;Term        = name | TOKEN | Group | Option | Repetition ;Group       = <span class="hljs-string">"("</span> Expression <span class="hljs-string">")"</span> ;Option      = <span class="hljs-string">"["</span> Expression <span class="hljs-string">"]"</span> ;Repetition  = <span class="hljs-string">"&#123;"</span> Expression <span class="hljs-string">"&#125;"</span> ;</code></pre><blockquote><p><strong>注意</strong>：<code>TOKEN</code> 表示在语法之外定义的终端符号。</p></blockquote><p>Example</p><pre><code class="hljs http">GET /zoos?id=1001,1002,1003</code></pre><h4 id="Long-running"><a href="#Long-running" class="headerlink" title="Long running"></a>Long running</h4><p>有时，POST、PUT、PATCH 或 DELETE 操作可能需要一段时间才能完成。如果需要等待该操作完成后才能向客户端发送响应，可能会造成不可接受的延迟。在这种情况下，请考虑将该操作设置为异步操作。返回 HTTP 状态代码 202（已接受），指示该请求已接受进行处理，但尚未完成。</p><p>应公开一个可返回异步请求状态的终结点，使客户端能够通过轮询状态终结点来监视状态。在 202 响应的 Location 标头中包含状态终结点的 URI。例如：</p><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">202</span> Accepted<span class="hljs-attribute">Location</span>: /api/status/12345</code></pre><p>如果客户端向此终结点发送 GET 请求，响应中应包含该请求的当前状态。（可选）响应中还可以包含预计完成时间，或者用于取消操作的链接</p><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">200</span> OK<span class="hljs-attribute">Content-Type</span>: application/json&#123;    "status":"In progress",    "link": &#123; "rel":"cancel", "method":"delete", "href":"/api/status/12345" &#125;&#125;</code></pre><p>如果异步操作创建了新资源，则该操作完成后，状态终结点应返回状态代码 303（查看其他）。在 303 响应中，包含一个 Location 标头用于提供新资源的 URI：</p><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">303</span> See Other<span class="hljs-attribute">Location</span>: /api/orders/12345</code></pre><p>有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/azure/architecture/patterns/async-request-reply" target="_blank" rel="noopener">异步请求-回复模式</a>。</p><h4 id="Sub-collection"><a href="#Sub-collection" class="headerlink" title="Sub-collection"></a>Sub-collection</h4><p>有时，API 需要让客户跨子集执行 <code>List/Search</code> 操作。例如，“API 图书馆”有一组书架，每个书架都有一系列书籍，而客户希望在所有书架上搜索某一本书。在这种情况下，建议在子集合上使用标准 <code>List</code>，并为父集合指定通配符集合 ID <code>&quot;-&quot;</code>。对于“API 图书馆”示例，我们可以使用以下 REST API 请求：</p><pre class="md-fences md-end-block ty-contain-cm modeLoaded">GET https://library.googleapis.com/v1/shelves/-/books/{id}</pre><blockquote><p><strong>注意</strong>：选择 <code>&quot;-&quot;</code> 而不是 <code>&quot;*&quot;</code> 的原因是为了避免需要进行 URL 转义。</p></blockquote><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变的属性）</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>对于非标准的操作，以上动词无法无法满足需求，可以在资源上使用“操作”子集合。 动作基本上类似于RPC的消息，用于对资源执行特定操作。 “动作”子集合可以看作是一个命令队列，可以将新的动作发布到该命令队列中，然后由API执行。定义标准动词如下：</p><ol><li>batch：批量操作</li><li>search：搜索操作</li></ol><pre><code class="hljs html">GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物GET /zoos/-/action/batch  批量查询POST /zoos/-/action/batch 批量更新POST /zoos/-/action/search 搜索</code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>对 <code>null</code> 和不存在的属性使用相同的语义</p><table><thead><tr><th>required</th><th>nullable</th><th>{}</th><th>{“example”:null}</th></tr></thead><tbody><tr><td><code>true</code></td><td><code>true</code></td><td>✗ No</td><td>✔ Yes</td></tr><tr><td><code>false</code></td><td><code>true</code></td><td>✔ Yes</td><td>✔ Yes</td></tr><tr><td><code>true</code></td><td><code>false</code></td><td>✗ No</td><td>✗ No</td></tr><tr><td><code>false</code></td><td><code>false</code></td><td>✔ Yes</td><td>✗ No</td></tr></tbody></table></li><li><p>路径使用 中划线 <code>-</code> 代替 下划线 <code>_</code>；</p><blockquote><p>在搜索引擎中，把中划线当做空格处理，而下划线是被忽略的。使用中划线是对搜索引擎友好的写法</p></blockquote><p>Example:</p>  <pre><code class="hljs applescript">/shipment-orders/&#123;shipment-order-<span class="hljs-built_in">id</span>&#125;</code></pre></li><li><p>范围</p><p>表示范围的字段<strong>应该</strong>使用半开区间和命名惯例 <code>[start_xxx, end_xxx)</code>，例如 <code>[start_key, end_key)</code> 或 <code>[start_time, end_time)</code>。通常 C ++ STL 库和 Java 标准库会使用半开区间语义。API <strong>应该</strong>避免使用其他表示范围的方式，例如 <code>(index, count)</code> 或 <code>[first, last]</code>。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完成以上这些，也仅仅是达到REST Level 2，由于Level 3 对于API风格影响不大，暂不涉及。对 HATEOAS 感兴趣，可以参考 Github v3 版本的API。</p><p><strong>参考链接</strong></p><ul><li><a href="https://www.infoq.cn/article/web-based-apps-archit-design" target="_blank" rel="noopener">架构风格与基于网络应用软件的架构设计</a></li><li><a href="https://cloud.google.com/apis/design" target="_blank" rel="noopener">Google Cloud API guide</a></li><li><a href="https://docs.microsoft.com/zh-cn/azure/architecture/best-practices/api-design" target="_blank" rel="noopener">Microsoft API design best practices</a></li><li><a href="https://opensource.zalando.com/restful-api-guidelines/" target="_blank" rel="noopener">Zalando RESTful API and Event Scheme Guidelines</a></li><li><a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md" target="_blank" rel="noopener">OpenAPI-Specification</a></li><li><a href="https://raw.githubusercontent.com/tlhunter/consumer-centric-api-design/master/pdf/Consumer-Centric%20API%20Design%20v0.4.0.pdf" target="_blank" rel="noopener">Consumer-Centric API Design v0.4.0.pdf</a></li><li><a href="https://stackoverflow.com/questions/19843480/s3-rest-api-and-post-method/19844272#19844272" target="_blank" rel="noopener">s3 rest api and post method</a></li><li><a href="https://stackoverflow.com/questions/29584903/what-is-hypermedia-hypermedia-controls-hypermedia-formats/29586455#29586455" target="_blank" rel="noopener">what is hypermedia hypermedia controls hypermedia formats</a></li><li><a href="https://martinfowler.com/articles/enterpriseREST.html" target="_blank" rel="noopener">Enterprise Integration Using REST</a></li><li><a href="https://restful-api-design.readthedocs.io/en/latest/intro.html" target="_blank" rel="noopener">Thoughts on RESTful API Design</a></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html">https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中往往会需要确定一个好的API风格，到底有哪些风格可以参考，API Style 的细节要点有哪些呢？&lt;/p&gt;
&lt;h3 id=&quot;Http-API-Style-有哪些？&quot;&gt;&lt;a href=&quot;#Http-API-Style-有哪些？&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="API Design" scheme="https://www.cyningsun.com/category/API-Design/"/>
    
    
      <category term="REST" scheme="https://www.cyningsun.com/tag/REST/"/>
    
  </entry>
  
  <entry>
    <title>跨服务错误处理</title>
    <link href="https://www.cyningsun.com/06-07-2020/unified-error-handling.html"/>
    <id>https://www.cyningsun.com/06-07-2020/unified-error-handling.html</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-09-06T12:57:31.515Z</updated>
    
    <content type="html"><![CDATA[<p>无论使用什么语言，错误处理都是系统中很关键的一个点。优雅的错误处理能够极大的提高代码的整洁度，而代码整洁度又直接影响可维护性，但是要实现优雅的错误处理却并非易事。那究竟难在哪里呢？</p><ol><li><p>重复的错误处理代码</p><blockquote><pre><code class="hljs json">_, err = fd.Write(p2[e:f])if err != nil &#123;    fmt.Println(err, ...)    return err&#125;</code></pre><p>在分层系统中（例如：Controller、Service、DAO），每一层都会重复以上代码</p></blockquote></li><li><p>原始错误的上下文</p><blockquote><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> authenticate(r.User)&#125;</code></pre><p>如果 <code>authenticate</code> 返回错误，那么 <code>AuthenticateRequest</code> 会将错误返回给调用者，调用者也可能会这样做，依此类推。 在程序的顶部，程序的主体将错误打印到屏幕或日志文件，所有打印的都会是： <code>No such file or directory</code></p></blockquote></li><li><p>原始错误 vs 错误码错误</p><blockquote><pre><code class="hljs go">errors.New(<span class="hljs-string">"connection error"</span>)<span class="hljs-comment">// vs </span><span class="hljs-keyword">var</span> errno <span class="hljs-keyword">uint32</span> = <span class="hljs-number">10001</span>errors.New(errno, <span class="hljs-string">"connection error"</span>)</code></pre><p>标准库或第三方应用库返回的是一般是上一种错误，然而H5或APP不可能根据字符串进行错误判断。因此在业务中需要把所有的错误进行统一封状为错误码错误返回，那么错误码错误中需要保存原始错误么？</p></blockquote></li><li><p>RPC错误 vs 业务错误</p><blockquote><ul><li>一方面，与业务层的错误相似，RPC框架也会自己的错误。而RPC框架往往也会集成一些包括过载处理、异常节点剔除的功能，依赖于对两种错误的识别能力。该如何设计错误才能让两者区分开来呢？</li><li>另一方面，无论是RPC框架错误和业务错误，调用端都需要进行统一解码（decode）。该如何设计错误才能让两者融合起来呢？</li></ul></blockquote></li></ol><p>从简单来看，所有问题是相互独立的，但是透过现象来看本质。以上问题又都有关联，在于进行错误模型设计。从业界各种框架的设计情况来看，可以把错误分为以下三种：</p><p><img src="/images/error-model.png" alt="error-model"></p><ul><li><p><strong>Error codes model</strong></p><!-- Errors are raised under various circumstances, from network failures to unauthenticated connections, each of which is associated with a particular code. --><blockquote><p>从网络故障到未经验证的连接，各种情况下都会引发错误，每种错误都可以都与特定错误码关联。</p></blockquote></li><li><p><strong>Standard error model</strong></p><!-- If an error occurs, return error codes instead, with an optional string error message that provides further details about what happened. --><blockquote><p>如果发生错误，则返回错误代码以及一条可选的字符串错误信息，该信息提供有关所发生事件的详细信息。</p></blockquote></li><li><p><strong>Richer error model</strong></p><!-- Enables servers to return and clients to consume additional error details. It further specifies a standard set of error message types to cover the most common needs (such as invalid parameters, quota violations, and stack traces). --><blockquote><p>允许服务器和客户端返回、使用额外的错误详细信息。它进一步指定了一组标准的错误消息类型，以满足最常见的需求（例如无效参数、配额冲突和堆栈跟踪）</p></blockquote></li></ul><p>三种类型的错误，层层递进，能够囊括的信息也越来越多。当然，信息越是丰富，框架实现难度越高，对使用者也越友好。在微信，svrkit 选择的模型是<code>Error codes model</code>；开源框架 grpc 选择的模型则是<code>Standard error model</code> ，但是本身支持<code>Richer error model</code>，参考：<a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener">googleapis</a></p><p>想清楚了问题，再看解决问题的方案：</p><ul><li><p>难点 1、2：可以按照以下两种思想来解决：<a href="https://www.cyningsun.com/08-19-2019/errors-are-values-cn.html">《Errors are values》</a>、<a href="https://www.cyningsun.com/09-09-2019/dont-just-check-errors-handle-them-gracefully-cn.html">Don’t just check errors, handle them gracefully</a></p></li><li><p>难点 3：错误的主要作用有以下两点：</p><blockquote><ul><li><p>根据错误的类型，进行针对性的处理</p></li><li><p>错误原因追踪</p></li></ul></blockquote><p>前者可以使用错误码来代替，后者可以简化为message。即，毋需保留错误本身，只需要将错误转化为错误码和message。</p></li><li><p>难点 4：即根据需要选择合适的错误模型，统一业务错误和框架错误。区分业务错误和框架错误，可以将 code 分段，框架优先占有指定的号段。</p><blockquote><p>更进一步，code 号段可以融合到服务治理中，在服务申请阶段分配对应的号段</p></blockquote></li></ul><!--  [**Error Handling**: How gRPC deals with errors, and gRPC error codes](https://grpc.io/docs/guides/error/)[Google API 错误模型](https://cloud.google.com/apis/design/errors) --><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-07-2020/unified-error-handling.html">https://www.cyningsun.com/06-07-2020/unified-error-handling.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无论使用什么语言，错误处理都是系统中很关键的一个点。优雅的错误处理能够极大的提高代码的整洁度，而代码整洁度又直接影响可维护性，但是要实现优雅的错误处理却并非易事。那究竟难在哪里呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重复的错误处理代码&lt;/p&gt;
&lt;blockquote&gt;
&lt;pr
      
    
    </summary>
    
    
      <category term="Error handling" scheme="https://www.cyningsun.com/category/Error-handling/"/>
    
    
      <category term="跨服务" scheme="https://www.cyningsun.com/tag/%E8%B7%A8%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Coaching中的版本思维</title>
    <link href="https://www.cyningsun.com/05-23-2020/why-version-is-important-when-coaching.html"/>
    <id>https://www.cyningsun.com/05-23-2020/why-version-is-important-when-coaching.html</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.049Z</updated>
    
    <content type="html"><![CDATA[<p>你是否在工作中遇到过以下场景：</p><blockquote><ul><li><p>A 同学在做一个方案设计，针对方案中的某些部分。A 同学纯凭口述向你讲述了下他面临的困境，并向你请教“我这样做对不对？”</p></li><li><p>B 同学是一个新手，在负责实现 XXX 功能。该功能的目标比较明确，但是具体实现有一定的探索性。 B 同学会向你确认“我是不是该这么做？”</p></li></ul></blockquote><p>此时，作为团队 Leader 或者导师的你，应该正面回答他“对还是不对”、“应该还是不应该” 么？</p><p>初出茅庐时，我也遇到过类似的问题，一般都会依据自己的经验给予解答，殊不知大错特错。每一次的解答都像给对方的习惯打了一剂增强针，引来对方后续源源不断的问题。</p><p>为什么会有源源不断的问题？</p><blockquote><ul><li>你的答案终止了他的思考，使其不能更进一步，能力原地打转</li><li>你的结论如果与其不同，可能会伤害其自信。以后遇到类似的问题，他将再次问你。</li><li>探索性的问题，他几乎不可能提供全部的Context，你根据描述产出的结论可能会是错的</li><li>限于其能力，其描述与实际产出可能有出入，不适合根据描述作出结论</li><li>可能会因为权威的因素，附和或顺从你的结论</li><li>无论结论对错，你都将负责结果，责任感缺位可能会降低其积极性</li></ul></blockquote><p>Coaching 的时候，会遇到有些同学或是“不敢拍板”；或是”相信权威“；或是”想走捷径“；或是”喜欢拍脑袋“，使用口头的描述来征求建议。让我意识到所有的建议，应该建立在“完整”的、“可版本管理”的产出物之上。</p><p><img src="/images/why-version-is-important-when-coaching/versioning-control.png" alt="versioning-control"></p><ol><li>该产出物可以是：</li></ol><blockquote><ol><li><p>设计文档</p></li><li><p>代码</p></li><li><p>步骤清单</p><p>…</p></li></ol></blockquote><ol start="2"><li>完整意味着，“建议”只能用来改良产出物，而不是用来完善或成为产出物的一部分。</li></ol><p><img src="/images/why-version-is-important-when-coaching/changes.svg" alt="changes"></p><p>只有如此，“建议”的才能产出一个新的版本。提问者可以根据两个版本的 <code>diff</code>，理解发生了什么，进行自我纠偏和总结。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/05-23-2020/why-version-is-important-when-coaching.html">https://www.cyningsun.com/05-23-2020/why-version-is-important-when-coaching.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是否在工作中遇到过以下场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A 同学在做一个方案设计，针对方案中的某些部分。A 同学纯凭口述向你讲述了下他面临的困境，并向你请教“我这样做对不对？”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B 同学是一个新手，在负责实
      
    
    </summary>
    
    
      <category term="Coaching" scheme="https://www.cyningsun.com/category/Coaching/"/>
    
    
      <category term="Coaching" scheme="https://www.cyningsun.com/tag/Coaching/"/>
    
  </entry>
  
  <entry>
    <title>使用 go race 排查 protobuf Marshal Panic</title>
    <link href="https://www.cyningsun.com/05-11-2020/proto-marshal-panic.html"/>
    <id>https://www.cyningsun.com/05-11-2020/proto-marshal-panic.html</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>在斋月节大促压测期间，有一个业务压测发现，有一个RPC调用，在高并发的情况下出现panic，而panic的位置是在微服务框架序列化的位置(proto.Marshal)。但是由于框架在近期没有做什么变更，而且业务最近也没上线什么新的需求。所有的Panic仅在并发量较高的时候偶然出现，并且被框架的recover捕获，因此判定此问题已经在线上很久，只是由于出现的概率较低没有被发现。</p><p>示例代码：</p><pre><code class="hljs go"><span class="hljs-number">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">11</span> <span class="hljs-number">19</span>:<span class="hljs-number">56</span>:<span class="hljs-number">32</span> http: <span class="hljs-built_in">panic</span> serving <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">59816</span>: runtime error: index out of <span class="hljs-keyword">range</span>goroutine <span class="hljs-number">20</span> [running]:net/http.(*conn).serve.func1(<span class="hljs-number">0xc00015e0a0</span>)/usr/local/Cellar/<span class="hljs-keyword">go</span>@<span class="hljs-number">1.12</span>/<span class="hljs-number">1.12</span><span class="hljs-number">.13</span>/libexec/src/net/http/server.<span class="hljs-keyword">go</span>:<span class="hljs-number">1769</span> +<span class="hljs-number">0x139</span><span class="hljs-built_in">panic</span>(<span class="hljs-number">0x13c1cc0</span>, <span class="hljs-number">0x175ad90</span>)/usr/local/Cellar/<span class="hljs-keyword">go</span>@<span class="hljs-number">1.12</span>/<span class="hljs-number">1.12</span><span class="hljs-number">.13</span>/libexec/src/runtime/<span class="hljs-built_in">panic</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">522</span> +<span class="hljs-number">0x1b5</span>github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/pb.encodeVarintPerson(<span class="hljs-number">0xc000228ec0</span>, <span class="hljs-number">0x3c</span>, <span class="hljs-number">0x3c</span>, <span class="hljs-number">0x3c</span>, <span class="hljs-number">0x1f</span>, <span class="hljs-number">0x3b</span>)/Users/yinhang.sun/Documents/workspace/src/github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/pb/person.pb.<span class="hljs-keyword">go</span>:<span class="hljs-number">146</span> +<span class="hljs-number">0x6a</span>.../Users/yinhang.sun/Documents/workspace/src/github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/pb/person.pb.<span class="hljs-keyword">go</span>:<span class="hljs-number">47</span> +<span class="hljs-number">0x5b</span>github.com/gogo/protobuf/proto.Marshal(<span class="hljs-number">0x14af2e0</span>, <span class="hljs-number">0xc0000bc040</span>, <span class="hljs-number">0x1</span>, <span class="hljs-number">0x140e400</span>, <span class="hljs-number">0xc0000bc040</span>, <span class="hljs-number">0xc00015c001</span>, <span class="hljs-number">0x0</span>).../usr/local/Cellar/<span class="hljs-keyword">go</span>@<span class="hljs-number">1.12</span>/<span class="hljs-number">1.12</span><span class="hljs-number">.13</span>/libexec/src/net/http/server.<span class="hljs-keyword">go</span>:<span class="hljs-number">2884</span> +<span class="hljs-number">0x2f4</span></code></pre><p>由于报错的结构体是业务最常用的一个，且报错的接口逻辑较深，通读代码也没有发现明显的点（其实是代码量太大了，很难关注的到）。报错又出现在框架层，panic 调用栈并没有提供任何有效信息。</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>经过背景的一系列分析之后，所有的排查思路都被打断了。好在我们发现报错的错误类型是<code>index out of range</code>，通过阅读proto.Marshal的代码之后发现，此函数分为三步：</p><pre><code class="hljs go">siz := info.Size(pb)b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, siz)<span class="hljs-keyword">return</span> info.Marshal(b, pb, <span class="hljs-literal">false</span>)</code></pre><ol><li>先获取结构体 Size</li><li>然后按照 Size 创建字节数组</li><li>将数据序列化到字节数组中</li></ol><p>因此，合理猜测是再获取 Size之后，Marshal之前，结构体的大小发生了变化。将 protobuf 的类型分类，可以排除固定长度的数值类型，剩下就是变长的 string 类型和 bytes 类型。虽然有了这个推论，由于发生panic的结构体十分复杂，还是很难定位到具体是哪个字段变化导致的。最后没有办法只有使用很笨的方法，修改 vendor 中的 protobuf 代码，添加日志，使用二分法，在info.Size()和info.Marshal()中打印字段的偏移量，并且在proto.Marshal中直接捕获发生panic的协程再打印数据，避免全部打印时panic请求与日志无法对应。然后对比排查，最终定位到了出现问题的字段，然后根据相关字段搜索相关代码，最终定位到了问题所在。</p><h3 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h3><p>修复完问题之后，促使我们反思，难道排查类似的问题一定要如此艰难么，有没有什么通用的方案来排查类似的问题呢。从问题源头出发，该问题本质来说还是数据的协程并发访问题，有了这个结论再看我们手头的已有工具，golang race 工具 出现在眼前。</p><p>理论上讲，可以在非生产环境打开 race 参数，辅助定位问题。说做就做，按照问题的原因，编写测试复现的test case</p><p><strong>进程缓存</strong></p><pre><code class="hljs go"><span class="hljs-keyword">const</span> Max = <span class="hljs-keyword">uint64</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">type</span> PersonCache <span class="hljs-keyword">struct</span> &#123;c *gocache.Cache&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPersonCache</span><span class="hljs-params">()</span> *<span class="hljs-title">PersonCache</span></span> &#123;one := &amp;PersonCache&#123;c:gocache.New(time.Minute, time.Hour)&#125;<span class="hljs-keyword">go</span> one.load()<span class="hljs-keyword">return</span> one&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PersonCache)</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i:=<span class="hljs-keyword">uint64</span>(<span class="hljs-number">0</span>); i &lt; Max; i++&#123;r :=  i % <span class="hljs-number">100</span>key := strconv.FormatUint(r,<span class="hljs-number">10</span>)newOne := &amp;pb.Person&#123;Id:                   proto.Uint64(r),Name:                 proto.String(<span class="hljs-string">"init Name"</span>),Age:                  proto.Uint32(rand.Uint32()),Address:   proto.String(<span class="hljs-string">"init address"</span>),&#125;p.c.Set(key, newOne, time.Minute)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PersonCache)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*pb.Person,<span class="hljs-keyword">bool</span>)</span></span> &#123;ret, ok := p.c.Get(key)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> ret.(*pb.Person),<span class="hljs-literal">true</span>&#125;</code></pre><p><strong>并发访问</strong></p><pre><code class="hljs go"><span class="hljs-keyword">const</span> letterBytes = <span class="hljs-string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="hljs-keyword">const</span> letterLength = <span class="hljs-built_in">len</span>(letterBytes)<span class="hljs-keyword">var</span> (c = cache.NewPersonCache())<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randString</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, n)<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> b &#123;b[i] = letterBytes[rand.Intn(<span class="hljs-built_in">len</span>(letterBytes))]&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;r := rand.Uint64() % cache.Maxkey := strconv.FormatUint(r, <span class="hljs-number">10</span>)p, ok := c.Get(key)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span>&#125;p.Name = proto.String(randString(rand.Int()%letterLength))time.Sleep(time.Nanosecond)p.Address = proto.String(randString(rand.Int()%letterLength))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Read</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;r :=  rand.Uint64() % cache.Maxkey := strconv.FormatUint(r,<span class="hljs-number">10</span>)p,ok := c.Get(key)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span>&#125;b,_ := proto.Marshal(p)w.Write(b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;http.HandleFunc(<span class="hljs-string">"/read"</span>, Read)http.HandleFunc(<span class="hljs-string">"/write"</span>, Write)fmt.Println(<span class="hljs-string">"server is listening on 8080"</span>)http.ListenAndServe(<span class="hljs-string">":8080"</span>, <span class="hljs-literal">nil</span>)&#125;</code></pre><p><strong>压测脚本</strong></p><pre><code class="hljs make">run:go run main.go &amp;&gt; normal.logracerun:go run -race main.go &amp;&gt; race.log benchmark:wrk -t1 -c2 -d30s http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;read &amp;wrk -t1 -c2 -d30s http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;write &amp;</code></pre><p><strong>日志结果</strong></p><pre><code class="hljs go">==================WARNING: DATA RACERead at <span class="hljs-number">0x00c000188140</span> by goroutine <span class="hljs-number">11</span>:  github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/pb.(*Person).Size()...Previous write at <span class="hljs-number">0x00c000188140</span> by goroutine <span class="hljs-number">55</span>:  main.Write()      /Users/yinhang.sun/Documents/workspace/src/github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">39</span> +<span class="hljs-number">0x271</span>...</code></pre><p>通过日志，可以很轻松的发现问题的原因。</p><h3 id="总结优化"><a href="#总结优化" class="headerlink" title="总结优化"></a>总结优化</h3><p>以上过程促使我们优化非生产环境的运行脚本，通过编译参数控制 -race 参数的开关，当再遇到类似的问题时，可以快速复现、定位、修复。</p><p><em>源码链接:</em></p><p><a href="https://github.com/cyningsun/go-test/tree/master/20200508-go-race" target="_blank" rel="noopener">https://github.com/cyningsun/go-test/tree/master/20200508-go-race</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/05-11-2020/proto-marshal-panic.html">https://www.cyningsun.com/05-11-2020/proto-marshal-panic.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;p&gt;在斋月节大促压测期间，有一个业务压测发现，有一个RPC调用，在高并发的情况下出现panic，而panic的位置是在微服务框架
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>移动端接入关键技术解析</title>
    <link href="https://www.cyningsun.com/05-03-2020/mobile-application-access-tech.html"/>
    <id>https://www.cyningsun.com/05-03-2020/mobile-application-access-tech.html</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>随着移动互联网成长成熟，移动端逐渐涌现出与WEB不一样的产品形态。</p><ul><li><p>互动</p><blockquote><p>越来越多的互动形式的出现，各种产品向社交化、娱乐化不断迈进</p></blockquote></li><li><p>媒体化</p><blockquote><p>从文字+图片为主的生态，逐渐向以视频为主的内容生态进化</p></blockquote></li><li><p>实时性</p><blockquote><p>内容生产逐渐由推荐式替代陈列式的形态；内容促达充分利用移动特性，实时触达用户，抢占用户的碎片时间</p></blockquote></li></ul><p>以上变化也推动了移动端接入技术演化发展，不再局限于常见的“请求-响应”的通信模式。</p><p>如果把移动端接入服务分为两层：流量接入层和应用接入层，本篇文章更多侧重于应用接入层，对于流量接入层如何实现，已经在<a href="https://www.cyningsun.com/02-03-2019/access-layer-architecture.html">《高可用的接入层架构细节实现》</a>覆盖。</p><h3 id="通信方式细分"><a href="#通信方式细分" class="headerlink" title="通信方式细分"></a>通信方式细分</h3><p>如果WEB时代接入层支持<code>单工</code>即可，客户端主动获取（PULL）数据；那么移动时代接入层需要支持<code>双工</code>，服务端也可以主动推送（PUSH）数据给客户端。如果客户端也像服务端一样可以24小时在线，那么只需要支持如此两种形式的通信方式即可，然而现实情况更为复杂。</p><ol><li><p>频繁打开关闭，如何进行离线数据同步</p></li><li><p>数据同步面临 网络状况复杂、同步速度、客户端耗电量等要求</p></li><li><p>多终端离线数据同步，如何做到数据不遗漏、不重复</p></li></ol><p>基于以上几点，可以降PUSH模式进行细分，拆解成两种模式：推送数据 + 数据同步（SYNC）。总结一下，在应用接入层需要支持以下三种形式的通信模式：</p><ul><li>RPC 负责“客户端向服务端请求数据（请求 - 响应）”的通信模式；</li><li>SYNC 负责“客户端从服务端同步数据”的通信模式；</li><li>PUSH 负责“服务端向在线客户端 PUSH 数据”的通信模式。 </li></ul><p><img src="/images/mobile-application-access/layer.png" alt="layer"></p><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>以下的部分重点讲述实现以上通信方式所需要的关键技术</p><h4 id="SYNC-机制"><a href="#SYNC-机制" class="headerlink" title="SYNC 机制"></a>SYNC 机制</h4><p>本质上 SYNC 是基于 SyncKey 的一种同步协议。微信在聊天界面拉取所有的未读消息，很卡很耗费流量。SYNC 机制是同步差量数据，以达到了提高通信效率、节省流量的效果。</p><p>在消息投递时选择合适的 <a href="https://www.cyningsun.com/12-26-2018/id-generator.html">ID生成方案</a>，为消息绑定递增的序号。推送消息时，不是把消息直接推送下去，而是发一个通知到客户端，客户端收到通知，根据用户上翻或者下翻的行为，带上一个最近收到消息的最大的序列号，按需、分页拉取消息。此机制保障了消息不重不漏，并且可以有效支持多终端数据同步。</p><p>客户端无需实时在线，对于用户不在线的情况，SYNC Server 会将差量数据保存在数据库中。当客户端下次连接到服务器时，再同步差量数据给用户。</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>服务端要做到主动把消息推送给客户端，就需要长连接的支持。那么长连接是不是就是 HTTP Keep Alive 呢？</p><p>HTTP Keep Alive 又被称为<code>持久连接</code>，允许 HTTP 请求结束之后将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求重用现存的连接。持久连接侧重于 HTTP 应用层。</p><p>所以常说的长连接是指 TCP 长连接。在移动网络下，网络状态复杂多变，长连接会因为以下因素断开：</p><ul><li><p>长连接进程退出</p><blockquote><p>客户端被系统 Kill 掉</p></blockquote></li><li><p>用户切换网络</p><blockquote><p>手机网络断开、Wi-Fi和蜂窝数据切换</p></blockquote></li><li><p>NAT超时</p><blockquote><p>设备休眠，NAT超时，导致公网IP回收</p></blockquote></li><li><p>DHCP 过期</p><blockquote><p>DHCP 租期过期，如果没有及时续约，同样会导致IP地址失效</p></blockquote></li></ul><p>如果发生长连接断开，那么就需要尽快发现并重连，此时就需要引入<code>心跳机制</code>.</p><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><p>在应用层做心跳检测连接断开，不熟悉的人不太能理解这一点。为什么使用应用层心跳，TCP 不是有 KeepAlive 机制么，通过这个机制来实现不就可以了吗？</p><pre><code class="hljs json">keepalive_probes  探测次数（9次）keepalive_time    探测的超时（2小时）keepalive_intvl   探测间隔(75s)</code></pre><p>事实上，TCP KeepAlive 的机制其实并不适用于此。Keep Alive 机制开启后，，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节（keepalive probe），会导致一下三种情况</p><ul><li>对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节</li><li>对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。</li><li>对方无任何响应：TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。一共尝试9次，即在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。</li></ul><p>显然默认值无法满足我们的需求，而修改过设置后就可以满足了吗？答案仍旧是否定的。因为 TCP KeepAlive 是用于检测连接的死活，而心跳机制则附带一个额外的功能：检测通讯双方的存活状态。两者听起来似乎是一个意思，但实际上并非如此。例如，某台服务器无法响应任何业务请求，使用 TCP 探针则仍旧能够确定连接状态。对客户端而言，此时的最好选择就是断线后重新连接其他服务器，而不是持续向当前服务器发送请求。</p><h3 id="应用层架构"><a href="#应用层架构" class="headerlink" title="应用层架构"></a>应用层架构</h3><p>理清楚以上关键点，再去设计架构，就比较清晰容易了。因为几大国民应用（淘宝、支付宝、微信、QQ）都是采用类似的实现方式，也从侧面进一步印证了该设计的合理性</p><p><img src="/images/mobile-application-access/application-architecture.png" alt="application-architecture"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实无论是 “单直播间百万CCU的弹幕服务” ，还是“单用户千万粉丝的红点服务”，在整体上都脱不开这个模型。只是要根据业务特性，在实现上做一定的修改变化以适应业务的需要</p><br/><p><strong>参考链接</strong> </p><ul><li><p><a href="https://www.infoq.cn/article/58WHhVew7kUYwHS*L6sE" target="_blank" rel="noopener">蚂蚁金服亿级并发下的移动端到端网络接入架构解析</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/66807833" target="_blank" rel="noopener">知乎千万级高性能长连接网关揭秘</a></p></li><li><p><a href="http://www.blogjava.net/yongboy/archive/2014/03/05/410636.html" target="_blank" rel="noopener">微信协议简单调研笔记</a></p></li><li><p><a href="https://www.infoq.cn/article/taobao-mobile-terminal-access-gateway-infrastructure" target="_blank" rel="noopener">阿里无线 11.11：手机淘宝移动端接入网关基础架构演进之路</a></p></li><li><p><a href="https://docs.huihoo.com/infoq/qconbeijing-evolution-and-enlightenment-of-qq-im-backend-architecture-20140426.pdf" target="_blank" rel="noopener">移动时代——QQ后台架构的演化与启示</a></p></li><li><p><a href="https://tech.meituan.com/2017/03/17/shark-sdk.html" target="_blank" rel="noopener">美团点评移动网络优化实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&mid=2247484552&idx=1&sn=40852d08a7fc5ce5bbef40e82b70f6b1" target="_blank" rel="noopener">魅族实时消息推送架构</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=209727496&idx=1&sn=86b64ddadcc91bc6b0741a870692b3c0" target="_blank" rel="noopener">360 如何实现支持数亿用户的长连消息系统</a></p></li><li><p><a href="https://yeqown.github.io/2020/04/02/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9E%B6%E6%9E%84-based-GOIM/" target="_blank" rel="noopener">消息推送架构-BASED-GOIM</a></p></li><li><p><a href="https://juejin.im/post/5cd12fa16fb9a0320b40ec32" target="_blank" rel="noopener">goim 中的 data flow 数据流转及思考</a></p></li><li><p><a href="http://yunxin.163.com/blog/im10-0608/" target="_blank" rel="noopener">移动IM开发指南2：心跳指令详解</a></p></li><li><p><a href="http://www.52im.net/thread-341-1-1.html" target="_blank" rel="noopener">Android端消息推送总结：实现原理、心跳保活、遇到的问题等</a></p></li><li><p><a href="https://juejin.im/post/5c6234426fb9a049e7029555" target="_blank" rel="noopener">Android 架构之长连接技术</a></p></li><li><p><a href="https://halfrost.com/advance_tcp/" target="_blank" rel="noopener">TCP 进阶</a></p></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/05-03-2020/mobile-application-access-tech.html">https://www.cyningsun.com/05-03-2020/mobile-application-access-tech.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;随着移动互联网成长成熟，移动端逐渐涌现出与WEB不一样的产品形态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;互动&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>监控告警成长之路</title>
    <link href="https://www.cyningsun.com/03-28-2020/site-reliability-engineering.html"/>
    <id>https://www.cyningsun.com/03-28-2020/site-reliability-engineering.html</id>
    <published>2020-03-27T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在过去的两年里，我们从零开始搭建了整个事业群的监控。目前整套系统接入200+的服务，700+的实例，收集了上万个指标。不停探索，历经曲折，方得自由。本文主要内容是总结两年间走过的路，趟过的坑，学习到的经验。</p><h3 id="一无所有"><a href="#一无所有" class="headerlink" title="一无所有"></a>一无所有</h3><p>业务刚开始上线时，是没有任何监控的，所有的监控都是依赖接入层的Nginx的监控数据，所有的故障都是从用户获取到反馈才能发现；排查问题依靠日志系统；从上游服务开始，逐层查询日志。每次发布上线内心都在敲锣打鼓。</p><h3 id="疲于奔命"><a href="#疲于奔命" class="headerlink" title="疲于奔命"></a>疲于奔命</h3><p>在业务第一个大版本上线之后，我们开始着手给业务系统接入监控，此时的选择是兄弟团队搭建的 openfalcon，使用 grafana 作为看板。基于对立体化监控的理解，开始着手建立各种纬度的看板</p><ul><li>服务纬度：<blockquote><p>提供 Client、Server 端视图，从服务的状态、性能、质量、容量四个维度，分析需要添加到看板的指标</p></blockquote></li><li>业务纬度：<blockquote><p>关注业务的关键路径，建立业务监控树，用于出现问题时，快速定位到具体的服务</p></blockquote></li><li>产品纬度：<blockquote><p>分析产品关键指标，构建公共看板</p></blockquote></li></ul><p>在这个阶段，我们投入了大量的人力资源到监控中，却收效甚微，主要有以下几点原因：</p><ol><li>从下往上的构建看板，需要不停的耗费人力补齐遗漏的指标</li><li>关注服务质量的指标多于关注产品质量指标，对于产品指标缺少足够的认识</li><li>受限于 openfalcon+grafana的能力，建立和维护 监控和告警，人力成本极高</li><li>所有人都要摸索熟悉监控的基础概念、门槛高</li><li>告警与业务关联度不高，业务一有波动就会误告，真正出现问题又发现没有配置告警</li></ol><p>在这个阶段，我们投入了大量的人力，建立和维护各种看板，处理各种告警，疲于奔命，却不尽如人意。</p><h3 id="前路始现"><a href="#前路始现" class="headerlink" title="前路始现"></a>前路始现</h3><p>在第一个版本稳定之后，很长一段时间没有大需求，促使我们考虑如何解决这些问题。同时在这个阶段，在部门内部开始开发自己的RPC框架，基于在微信的工作经验，促使我们把目光投向 Prometheus 等基于数据的监控平台。</p><p>在监控方面，我们使用 <a href="https://www.cyningsun.com/09-15-2019/micro-service-monitor-prometheus-client.html">SDK（数据上报）</a> + <a href="https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html">Prometheus（数据收集）</a>+ Grafana（监控看板），构建了更灵活方便的看板</p><ul><li>服务纬度<blockquote><p>在开发RPC框架的同时，将服务纬度的上报直接嵌入框架中，同时提供SDK给兄弟团队用于现有服务的接入。然后统一维护了两套服务看板：全局看板，详细看板。前者负责日常运营，后者负责排查问题。</p></blockquote></li><li>业务&amp;产品纬度<blockquote><p>SDK设计了统一简单的上报接口，方便构建业务、产品相关的看板</p></blockquote></li></ul><p>至此，服务纬度的数据变成了可以逐渐迭代优化的统一视图，随着经验的积累，对监控的认识越深刻，看板使用越是应手。</p><p>在告警方面，使用 <a href="https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html">Promtheus（数据计算）</a> + Promgen（规则管理） + AlertManager（告警管理） + Webhook （告警调用）+ 企业微信群，构建了完善的告警链条。</p><h3 id="方得自由"><a href="#方得自由" class="headerlink" title="方得自由"></a>方得自由</h3><p>在监控告警中，我们会频繁遇到以下问题：</p><ol><li>阈值设定：不同业务场景，不同指标，如何衡量阈值是过于宽松，还是过于严格。</li><li>流量波动：在理想的世界里，流量是有起伏规律的，监控系统能够掌握这种规律，当流量上升时，告警阈值自动上升</li><li>瞬态告警：每个人都会遇到这样的情况，同样的问题隔段时间就出现一次，持续时间不过几分钟，来得快去得也快。说实话，你已经忙得不可开交了，近期内也不大会去排除这种问题。是忽略呢？还是忽略呢？</li><li>信息过载：典型的信息过载场景是，给所有需要的地方都加上了告警，以为这样即可高枕无忧了，结果随着而来的是，各种来源的告警轻松挤满你的收件箱。</li><li>故障定位：在相对复杂的业务场景下，一个“告警事件” 除了包含“时间”(何时发生)、“地点”(哪个服务器/组件)、“内容”(包括错误码、状态值等)外，还包含地区、机房、服务、接口等，故障定位之路道阻且长。</li></ol><p>那么目前我们解决的怎么样了呢？</p><ul><li>问题 1、2，为了解决该问题，在监控平台里，引入了<a href="https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html">异常检测算法（anomaly detection）</a> ，得到了很好的解决</li><li>问题 3，使用Prometheus的能力，得以解决</li><li>问题 4，我们对告警指标进行分级，只在调用链条的最上游配置细化的重要告警指标，告警之后通过链接跳转到对应的详细看板进行问题排查，告警更少更精确可查，维护起来也更简单了。</li><li>问题 5，目前仍然没有得到很好的解决，但是已经有了方案，将在后续进一步优化</li></ul><h3 id="未来之路"><a href="#未来之路" class="headerlink" title="未来之路"></a>未来之路</h3><p>基于 <a href="https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html">Prometheus 的数据平台能力</a>，可以构建出业务所有服务的调用的树状图，并且当时的错误变化情况，进行自动故障根源分析，这也是我们以后将要做的</p><BR/>附：<p><img src="/images/site-reliability-engineering/overview.png" alt="overview"><br>（全局看板部分视图）</p><p><img src="/images/site-reliability-engineering/detail1.png" alt="detail1"><br><img src="/images/site-reliability-engineering/detail2.png" alt="detail2"><br>（详细看板部分视图）</p><p><strong>参考链接</strong><br><a href="https://www.jianshu.com/p/06c7dd803d4a" target="_blank" rel="noopener">https://www.jianshu.com/p/06c7dd803d4a</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/03-28-2020/site-reliability-engineering.html">https://www.cyningsun.com/03-28-2020/site-reliability-engineering.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在过去的两年里，我们从零开始搭建了整个事业群的监控。目前整套系统接入200+的服务，700+的实例，收集了上万个指标。不停探索，历经曲折，方
      
    
    </summary>
    
    
      <category term="SRE" scheme="https://www.cyningsun.com/category/SRE/"/>
    
    
      <category term="Alert" scheme="https://www.cyningsun.com/tag/Alert/"/>
    
  </entry>
  
  <entry>
    <title>缓存(3) —— 一致性</title>
    <link href="https://www.cyningsun.com/03-07-2020/high-concurrency-cache-consistent.html"/>
    <id>https://www.cyningsun.com/03-07-2020/high-concurrency-cache-consistent.html</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>毋庸置疑，数据只要有多个副本（replica/copy），就一定会存在一致性的问题。数据多副本一般有以下作用：</p><ol><li>容错手段：当某一个副本出现故障时，可以从其他副本读取数据，确保容错并避免单点问题。</li><li>改善性能：在多个位置具有相同的数据可以降低数据访问延迟<blockquote><ul><li>将数据副本存放在更靠近用户的位置，典型的例子：CDN</li><li>将数据放在高性能的存储介质中，典型的例子：缓存</li></ul></blockquote></li><li>分担负荷：由于数据存在多个副本，每个副本都可以承担一部分查询请求。</li></ol><p>通常，对副本的访问与对原始数据的访问应当是一致的，副本本身对外部用户应该是透明的，这就是通常理解的一致性。人人都在谈一致性，但是大家说的一致性却不一定是同一个东西。</p><h3 id="一致性视角"><a href="#一致性视角" class="headerlink" title="一致性视角"></a>一致性视角</h3><p>从使用的角度，数据从存储系统分离取出来之后，会经过业务系统的加工，最终展现给普通用户。</p><p><img src="/images/high-concurrency-cache-consistent/consistent-view.png" alt="consistent-view.png"></p><p>因此，存在两个视角可以来看数据一致性的问题，分别是：</p><ul><li>V1: 服务端视角</li><li>V2: 用户视角</li></ul><h4 id="用户端一致性"><a href="#用户端一致性" class="headerlink" title="用户端一致性"></a>用户端一致性</h4><p>首先定义如下场景：</p><ul><li>存储系统：存储系统存储了用户的数据。</li><li>用户A：往存储系统写入数据，并读取自己与其他人的数据。</li><li>用户B、用户C：读取自己与其他人的数据。</li></ul><p>从用户的角度来看，一致性包含如下三种情况：</p><ul><li><strong>强一致性</strong>：假如A先写入了一个值到存储系统，存储系统保证后续A，B，C的读取操作都将返回最新值。当然，如果写入操作“超时”，那么成功或者失败都是可能的，A不应该做任何假设。</li><li><strong>弱一致性</strong>：假如A先写入了一个值到存储系统，存储系统不能保证后续A，B，C的读取操作是否能够读取到最新值。</li><li><strong>最终一致性</strong>：最终一致性是弱一致性的一种特例。假如A首先写入一个值到存储系统，存储系统保证如果后续没有写操作更新同样的值，A，B，C的读取操作“最终”都会读取到A写入的最新值。“最终”一致性有一个“不一致窗口”的概念，它特指从A写入值，到后续A，B，C读取到最新值的这段时间。“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制协议要求同步的副本数。</li></ul><p>最终一致性描述比较粗略，其他常见的变体如下：</p><ul><li><strong>读写（Read-your-writes）一致性</strong>：如果客户端A写入了最新的值，那么A的后续操作都会读取到最新值。但是其他用户（比如B或者C）可能要过一会才能看到。</li><li><strong>会话（Session）一致性</strong>：要求用户和存储系统交互的整个会话期间保证读写一致性。如果原有会话因为某种原因失效而创建了新的会话，原有会话和新会话之间的操作不保证读写一致性。</li><li><strong>单调读（Monotonic read）一致性</strong>：如果客户端A已经读取了对象的某个值，那么后续操作将不会读取到更早的值。</li><li><strong>单调写（Monotonic write）一致性</strong>：客户端A的写操作按顺序完成，这就意味着，对于同一个客户端的操作，存储系统的多个副本需要按照与客户端相同的顺序完成。</li></ul><p>从用户角度看，一般要求业务系统能够支持读写一致性，会话一致性，单调读，单调写等特性，以放松一致性来提供高可用性。</p><h4 id="服务端一致性"><a href="#服务端一致性" class="headerlink" title="服务端一致性"></a>服务端一致性</h4><p>在开始之前确定一些定义：<br>N = 存储数据副本的节点数<br>W = 更新完成之前需要确认收到更新的副本数<br>R = 通过读取操作访问数据对象时获取的副本数</p><p>如果 W + R &gt; N，则写集和读集始终重叠，并且可以保证强一致性。在实现同步复制的主备份 Mysql 方案中，N = 2，W = 2 和 R = 1。无论客户端从哪个副本中读取内容，都将始终获得一致的结果。在启用从备份读取的异步复制中，N = 2，W = 1 和 R = 1。在这种情况下，R + W = N，则不能保证一致性。</p><blockquote><p>在需要提供高性能和高可用性的分布式存储系统中，副本的数量通常大于两个。仅专注于容错的系统通常使用N = 3（W = 2和R = 2配置）。微信早期的 QuorumKV，就是使用的该配置</p></blockquote><p>当W + R &lt;= N，会出现弱/最终一致性，这意味着读写集可能不会重叠。是否可以实现读写、会话和单调一致性通常取决于client与执行分布式协议的服务器的“粘性”。如果每次都是同一台服务器，那么就比较容易保证读写和单调读。同时也使得负载平衡管理和容错稍微有点困难，但这是一个简单的解决方案。</p><p>从业务系统的角度看，存储系统可以支持强一致性，也可以为了性能考虑只支持最终一致性。无法提供一致性的系统，使用比较麻烦。</p><h3 id="复制机制"><a href="#复制机制" class="headerlink" title="复制机制"></a>复制机制</h3><p>从存储系统的可用性来看，组合“存储结构”和“复制机制”有以下三种模式：</p><ul><li>单主，异步/异步复制</li><li>自动选主，同步复制</li><li>多主可用，同步复制</li></ul><p><img src="/images/high-concurrency-cache-consistent/replication-struct.png" alt="replication-struct.png"></p><p>三种模式从实现难度来看，从低到高。“<a href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84">内存数据库 + 磁盘数据库</a>” 类型的存储架构，如果将两者看作整体，很容易理解其“单主”的形态：</p><ol><li>读请求大部分命中内存数据库，少数落到磁盘数据库</li><li>写请求写到磁盘数据库，然后由磁盘数据库同步到内存数据库</li></ol><p>考虑通用架构，由于内存数据库存在数据丢失风险，数据一般会写入磁盘数据库，然后再写入或同步到内存数据库。因此在很多公司的设计中（例如Facebook和我司），均采用异步复制的方式来更新缓存。具体到Mysql，则是利用了磁盘数据库的提交日志（即Commit Log，以Mysql为例，binlog）自动异步更新缓存</p><p><img src="/images/high-concurrency-cache-consistent/facebook-data-replication.png" alt="facebook-data-replication.png"><br>Facebook</p><p><img src="/images/high-concurrency-cache-consistent/shopee-data-replication.png" alt="shopee-data-replication.png"><br>shopee</p><p>当然，异步复制只能解决最终一致性，无法解决用户角度强一致性的场景。对于这种场景可以通过 “<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">Cache Aside Pattern</a>” 来解决。</p><p>参考链接：</p><ul><li><a href="https://coolshell.cn/articles/10910.html" target="_blank" rel="noopener">分布式系统的事务处理</a></li><li><a href="https://queue.acm.org/detail.cfm?id=1466448" target="_blank" rel="noopener">Eventually Consistent</a></li><li><a href="https://myslide.cn/slides/20807" target="_blank" rel="noopener">微信后台架构与基础设施简介</a></li><li><a href="https://en.wikipedia.org/wiki/Replication_%28computing%29" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Replication_(computing)</a></li><li><a href="https://www.usenix.org/conference/nsdi13/scaling-memcache-facebook" target="_blank" rel="noopener">Scaling Memcache at Facebook</a></li><li><a href="https://static001.geekbang.org/con/40/pdf/4109523403/file/%E6%9E%97%E9%94%8B-Shopee%E6%95%B0%E6%8D%AE%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0.pdf" target="_blank" rel="noopener">Shopee数据事件中心的设计和实现</a></li><li><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">缓存更新的套路</a></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/03-07-2020/high-concurrency-cache-consistent.html">https://www.cyningsun.com/03-07-2020/high-concurrency-cache-consistent.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;毋庸置疑，数据只要有多个副本（replica/copy），就一定会存在一致性的问题。数据多副本一般有以下作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="一致性" scheme="https://www.cyningsun.com/tag/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>缓存(2) —— 命中率</title>
    <link href="https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html"/>
    <id>https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html">上一篇</a>文章讲述了缓存的本质，使用快速的存储，承载尽可能多的请求，那么衡量缓存服务质量有两个标准：</p><ol><li>平均访问延迟AAT（Average Access Time） = HitTime + (Miss Ratio * Miss Penalty)</li><li>缓存命中率 Cache Hit Ratio = [Cache Hits / (Cache Hits + Cache Misses)] x 100 %<br>前者因为不涉及技术问题，不再详谈。后者，却是至关重要。</li></ol><p>缓存命中（Cache Hit），符合我们预期，喜闻乐见；缓存未命中（Cache Miss），就很有可能要了老命。各种称谓也很繁杂</p><blockquote><p>国内按照场景分称为：缓存击穿、缓存穿透、缓存雪崩<br>国外使用不同词汇表达同一含义：<a href="https://en.wikipedia.org/wiki/Thundering_Herd" target="_blank" rel="noopener">Thundering Herd</a>、<a href="https://en.wikipedia.org/wiki/Cache_stampede" target="_blank" rel="noopener">Cache stampede</a>、<a href="https://books.google.com/books?id=daDAnXPnRkcC&pg=PA353" target="_blank" rel="noopener">Dog-Pile Effect</a></p></blockquote><p>以下的篇幅分场景来讲下缓存不命中的场景和常见的解决方案</p><h3 id="数据不在缓存"><a href="#数据不在缓存" class="headerlink" title="数据不在缓存"></a>数据不在缓存</h3><h4 id="Cold-cache"><a href="#Cold-cache" class="headerlink" title="Cold cache"></a>Cold cache</h4><p>缓存最好是使用渐进式策略进行warmup，要做到业务无感就需要引入中间组件，例如Facebook使用 mcrouter 来预热新机群</p><p><img src="/images/high-concurrency-cache-miss/mcrouter.png" alt="mcrouter.png"></p><h4 id="Adding-removing-nodes"><a href="#Adding-removing-nodes" class="headerlink" title="Adding / removing nodes"></a>Adding / removing nodes</h4><p>模哈希路由的主要缺点是缓存节点的数量需要保持稳定，增加节点或者节点下线将导致大多数缓存散列到新节点。即使这些值仍在缓存中，如果将Key分发给其他节点，查找也会 <code>Miss</code>。使用<a href="https://juejin.im/post/5ae1476ef265da0b8d419ef2" target="_blank" rel="noopener">一致性哈希</a>可以使缓存节点增减更加灵活。</p><p><img src="/images/high-concurrency-cache-miss/consistent-hash.png" alt="consistent-hash.png"></p><h4 id="Out-of-cache-memory"><a href="#Out-of-cache-memory" class="headerlink" title="Out of cache memory"></a>Out of cache memory</h4><p>对于不在内存中的数据，有两种可能：</p><ol><li>缓存时间到期（TTL），数据从缓存中淘汰出去了</li><li>由于之前没有访问，数据不在缓存中</li></ol><p>对于不在缓存的访问，处理的方式比较统一，严格限制并发访问下游存储，具体落实到各个公司各不相同：</p><ul><li>Instagram： 在C++语言中使用 <a href="https://instagram-engineering.com/thundering-herds-promises-82191c8af57d" target="_blank" rel="noopener">Promise</a> 模式来限制并发访问</li><li>Google：在Go语言中使用 <a href="https://pkg.go.dev/golang.org/x/sync/singleflight?tab=doc" target="_blank" rel="noopener">Single Flight</a> 来限制并发访问</li><li>Facebook：使用 <a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">Leases</a> 机制，保证同一时间只有第一个访问到不在缓存的请求可以访问下游，并将其添加到缓存；其他请求则返回未命中，然后等待一段时间再次尝试访问缓存。</li></ul><h3 id="数据不存在"><a href="#数据不存在" class="headerlink" title="数据不存在"></a>数据不存在</h3><p>对于数据不存在的情况，尽量通过参数校验的情况予以拦截。拿公众号文章的链接举例:</p><p><strong>早期</strong></p><pre><code class="hljs go">http:<span class="hljs-comment">//mp.weixin.qq.com/s?__biz=MzAwNTMxMzg1MA==&amp;mid=2654067776&amp;idx=1&amp;sn=b4c1261a785a59dd6268142b0b358b50&amp;scene=4#wechat_redirect</span></code></pre><p>可以看到该链接中几个关键的请求参数：</p><blockquote><p>__biz=MzAwNTMxMzg1MA== // 公众号ID base64<br>mid=2654067776        // 推送ID<br>idx=1                // 消息位置（每次推送有多篇文章）</p></blockquote><p>有这些参数，完全可以随意拼接参数，伪造URL爬取微信公众号的数据。如果URL并没有对应的数据，那么微信就会遇到数据不存在穿透到下层存储的问题。</p><p><strong>中期</strong></p><pre><code class="hljs go">http:<span class="hljs-comment">//mp.weixin.qq.com/s?timestamp=1469352451&amp;src=3&amp;ver=1&amp;signature=56kgMk71dIMM59VsUWlueRZ1ljkNODBEgrW78vmgXfJs82nkMESO8W*7EXf2ylOyamiUvL0zQ5OAfVraI8tPp-Hhdzv5WRQKSPa-MF6hiFMZf7rqxmZRvsYsd-7WSsy5qiafAQNfxBSkWzSulgB575CWRYnn6QZTRJ4NdR*gs0s=</span></code></pre><p>唔，带上时间戳了，不太好搞了，但是如果知道签名策略，仍然可以解出来必需的访问参数</p><p><strong>最新</strong></p><pre><code class="hljs go">https:<span class="hljs-comment">//mp.weixin.qq.com/s/zCyzv_DRzLSUjhs5E9gZtQ</span></code></pre><p>最新版就丧心病狂了，直接转成了短链接，外部人员丝毫没有办法，完美解决了问题。</p><p>对于无法通过数据拦截的，则需要根据依赖额外的过滤器来进行甄别，例如：<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">Bloom filter</a>、<a href="https://coolshell.cn/articles/17225.html" target="_blank" rel="noopener">Cuckoo filter</a> 等。以容忍误报置换空间，节约存储资源</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了以上常规且通用的处理方案，业界还有各种贴合业务场景的方案，在此不过多涉及。</p><blockquote><p>非常规方案：</p><ul><li><a href="http://highscalability.com/bunch-great-strategies-using-memcached-and-mysql-better-together" target="_blank" rel="noopener">Pre-Populating Cache</a></li><li><a href="https://kovyrin.net/2008/03/10/dog-pile-effect-and-how-to-avoid-it-with-ruby-on-rails-memcache-client-patch/" target="_blank" rel="noopener">monkey patch</a></li><li>Randomize TTL values</li></ul></blockquote><br/><p>参考链接 </p><ol><li><a href="https://engineering.fb.com/web/introducing-mcrouter-a-memcached-protocol-router-for-scaling-memcached-deployments/" target="_blank" rel="noopener">https://engineering.fb.com/web/introducing-mcrouter-a-memcached-protocol-router-for-scaling-memcached-deployments/</a></li><li><a href="https://github.com/leafney/wxSpider/blob/master/GETCONTENT.md" target="_blank" rel="noopener">https://github.com/leafney/wxSpider/blob/master/GETCONTENT.md</a></li><li><a href="https://instagram-engineering.com/thundering-herds-promises-82191c8af57d" target="_blank" rel="noopener">https://instagram-engineering.com/thundering-herds-promises-82191c8af57d</a></li></ol><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html">https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.cyningsun.com/02-02-2020/high-concurrency-hierarc
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="命中率" scheme="https://www.cyningsun.com/tag/%E5%91%BD%E4%B8%AD%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Prometheus</title>
    <link href="https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html"/>
    <id>https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html</id>
    <published>2020-02-21T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>对很多人来说，未知、不确定、不在掌控的东西，会有潜意识的逃避。当我第一次接触 Prometheus 的时候也有类似的感觉。对初学者来说， Prometheus 包含的概念太多了，门槛也太高了。</p><blockquote><p>概念： Instance、Job、Metric、Metric Name、Metric Label、Metric Value、Metric Type（Counter、Gauge、Histogram、Summary）、DataType（Instant Vector、Range Vector、Scalar、String）、Operator、Function</p></blockquote><p>马云说：“虽然阿里巴巴是全球最大的零售平台，但阿里不是零售公司，是一家数据公司”。Prometheus 也是一样，本质来说是一个基于数据的监控系统。</p><h3 id="日常监控"><a href="#日常监控" class="headerlink" title="日常监控"></a>日常监控</h3><p>假设需要监控 WebServerA 每个API的请求量为例，需要监控的维度包括：服务名（job）、实例IP（instance）、API名（handler）、方法（method）、返回码(code)、请求量（value）。</p><p><img src="/images/hidden-secret-to-understanding-prometheus/sql.png" alt="promql"></p><p>如果以SQL为例，演示常见的查询操作：</p><ol><li>查询 method=put 且 code=200 的请求量(红框)<blockquote><p>SELECT * from http_requests_total WHERE code=”200” AND method=”put” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li><li>查询 handler=prometheus 且 method=post 的请求量(绿框)<blockquote><p>SELECT * from http_requests_total WHERE handler=”prometheus” AND method=”post” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li><li>查询 instance=10.59.8.110 且 handler 以 query 开头 的请求量(绿框)<blockquote><p>SELECT * from http_requests_total WHERE handler=”query” AND instance=”10.59.8.110” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li></ol><p>通过以上示例可以看出，在常用查询和统计方面，日常监控多用于根据监控的维度进行查询与时间进行组合查询。<strong>如果监控100个服务，平均每个服务部署10个实例，每个服务有20个API，4个方法，30秒收集一次数据，保留60天。那么总数据条数为：100(服务)* 10（实例）* 20（API）* 4（方法）* 86400（1天秒数）* 60(天) / 30（秒）= 138.24 亿条数据，写入、存储、查询如此量级的数据是不可能在Mysql类的关系数据库上完成的</strong>。因此 Prometheus 使用 TSDB 作为 存储引擎</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>TSDB 作为 Prometheus 的存储引擎完美契合了监控数据的应用场景</p><ul><li>存储的数据量级十分庞大</li><li>大部分时间都是写入操作</li><li>写入操作几乎是顺序添加，大多数时候数据到达后都以时间排序</li><li>写操作很少写入很久之前的数据，也很少更新数据。大多数情况在数据被采集到数秒或者数分钟后就会被写入数据库</li><li>删除操作一般为区块删除，选定开始的历史时间并指定后续的区块。很少单独删除某个时间或者分开的随机时间的数据</li><li>基本数据大，一般超过内存大小。一般选取的只是其一小部分且没有规律，缓存几乎不起任何作用</li><li>读操作是十分典型的升序或者降序的顺序读</li><li>高并发的读操作十分常见</li></ul><p>那么 TSDB 是怎么实现以上功能的呢？</p><pre><code class="hljs json">"labels": [&#123;"latency":        "500"&#125;]"samples":[&#123;"timestamp": 1473305798,"value": 0.9&#125;]</code></pre><p>原始数据分为两部分 label, samples。前者记录监控的维度（标签:标签值），指标名称和标签的可选键值对唯一确定一条时间序列（使用 series_id 代表）；后者包含包含了时间戳（timestamp）和指标值（value）。</p><pre><code class="hljs txt">series^│. . . . . . . . . . . .   server&#123;latency&#x3D;&quot;500&quot;&#125;│. . . . . . . . . . . .   server&#123;latency&#x3D;&quot;300&quot;&#125;│. . . . . . . . . .   .   server&#123;&#125;│. . . . . . . . . . . . v&lt;-------- time ----------&gt;</code></pre><p>TSDB 使用 timeseries:doc:<timestamp>:<series_id> 为 key 存储 value。为了加速常见查询查询操作：label 和 时间范围结合。TSDB 额外构建了三种索引：<code>Series</code>, <code>Label Index</code> 和 <code>Time Index</code>。</p><p>以标签 <code>latency</code> 为例：</p><ul><li>Series<blockquote><p>存储两部分数据。一部分是按照字典序的排列的所有标签键值对序列（series）；另外一部分是时间线到数据文件的索引，按照时间窗口切割存储数据块记录的具体位置信息，因此在查询时可以快速跳过大量非查询窗口的记录数据</p></blockquote></li><li>Label Index<blockquote><p>每对 label 为会以 index:label:<latency> 为 key，存储该标签所有值的列表，并通过引用指向 <code>Series</code> 该值的起始位置。</p></blockquote></li><li>Time Index<blockquote><p>数据会以 index:timeseries:<series_id>:<split_time> 为 key，指向对应时间段的数据文件</p></blockquote></li></ul><h3 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h3><p>强大的存储引擎为数据计算提供了完美的助力，使得 Prometheus 与其他监控服务完全不同。Prometheus 可以<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#time-series-selectors" target="_blank" rel="noopener">查询出不同的数据序列</a>，然后再加上<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/" target="_blank" rel="noopener">基础的运算符</a>，以及<a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="noopener">强大的函数</a>，就可以执行 <code>metric series</code> 的矩阵运算（见下图）。</p><p><img src="/images/hidden-secret-to-understanding-prometheus/matrix.png" alt="time series matrix"></p><p>如此，Promtheus体系的能力不弱于监控界的“数据仓库”+“计算平台”。因此，在大数据的开始在业界得到应用，就能明白，这就是监控未来的方向。</p><h3 id="一次计算，处处查询"><a href="#一次计算，处处查询" class="headerlink" title="一次计算，处处查询"></a>一次计算，处处查询</h3><p>当然，如此强大的计算能力，消耗的资源也是挺恐怖的。因此，查询预计算结果通常比每次需要原始表达式都要快得多，尤其是在仪表盘和告警规则的适用场景中，仪表盘每次刷新都需要重复查询相同的表达式，告警规则每次运算也是如此。因此，Prometheus提供了 Recoding rules，可以预先计算经常需要或者计算量大的表达式，并将其结果保存为一组新的时间序列， 达到 <a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#avoiding-slow-queries-and-overloads" target="_blank" rel="noopener">一次计算，多次查询</a> 的目的</p><p><img src="/images/hidden-secret-to-understanding-prometheus/rules.png" alt="prometheus rules"></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html">https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;对很多人来说，未知、不确定、不在掌控的东西，会有潜意识的逃避。当我第一次接触 Prometheus 的时候也有类似的感觉。对初学者来说， P
      
    
    </summary>
    
    
      <category term="SRE" scheme="https://www.cyningsun.com/category/SRE/"/>
    
    
      <category term="本质" scheme="https://www.cyningsun.com/tag/%E6%9C%AC%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>缓存（1）—— 总述：分级存储</title>
    <link href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html"/>
    <id>https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html</id>
    <published>2020-02-01T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>原本想聊下缓存的相关技术，但是纯聊缓存未免眼界太窄，视野太小，既然打算写一个系列，不如就先从底层聊起，然后慢慢铺开。本篇先聊分级存储引入的问题，以及对服务和架构的影响：服务分类、分层架构（服务分层）。</p><h3 id="分级存储"><a href="#分级存储" class="headerlink" title="分级存储"></a>分级存储</h3><p>了解计算机组成的都知道，存储结构是分层（级）的，到底是什么原因呢？</p><p><img src="/images/high-concurrency-hierarchical-storage/computer-architecture.png" alt="computer-architecture.png"></p><p>用户期望提供尽可能高的存取速度和尽量大的存储容量，但价格尽可能低。矛盾的现实是：</p><ol><li>速度越快，单位存储价格就越高；</li><li>在一定的单位存储价格下，容量越大，存储器的总价就越高。</li></ol><p>计算机发挥性能要求存储存取速度与CPU相匹配。离 CPU 越近的存储，速度越快，成本越高，容量也因此越小。</p><p>数据从产生的那一刻起就自然地进入到了一个循环，经过创建、访问、迁移、归档和销毁，最终完成一个生命周期，而这个过程必然需要良好的管理，否则，要么是浪费了过多的资源；要么是资源不足降低了工作效率。</p><p>数据生来并非平等的。不同的数据具有不同的价值，如业务生产相关的关键数据和日志；同一数据在其不同阶段价值也不一样。纵向来看，即访问越多，其价值越高。</p><p><strong>分级存储</strong>，利用了数据访问的<a href="https://en.wikipedia.org/wiki/Locality_of_reference" target="_blank" rel="noopener">局部性原理</a>，使用快速的存储，存储访问最多的数据。当访问数据时，先从内存中取，如果内存中没有，再从磁盘读入内存。以后访问该区域的数据时，就不用再从磁盘读取，因此上层的存储都可以认为是下层的缓存。</p><p>总结一下：局部性原理的缓存体系，平衡了速度和价格的矛盾。</p><h3 id="分级问题"><a href="#分级问题" class="headerlink" title="分级问题"></a>分级问题</h3><p>分级存储并非是解决问题的银弹，解决了矛盾的同时，也给存储本身引入了一些问题：</p><ol><li>命中率<blockquote><p>当数据被上层存储覆盖时，一切尽在掌握，分层存储的机制可以正常的工作。当热点数据穿透上层落到下层时，下层存储的性能将成为整体的瓶颈。</p></blockquote></li><li>一致性<blockquote><p>作为缓存，上层存储在提高系统处理性能的同时，也可能会“滞留”IO操作。如果在系统发生故障时，仍有部分IO“滞留”，真正写到下层存储的数据就会少于服务实际写出的数据，导致数据不一致。</p></blockquote></li><li>存储管理<blockquote><p>由于存在多个层级，数据在生命周期内就需要在不同层级间流动迁移。不同层级需要合适的迁移淘汰策略，满足业务场景的需求。缓存需要缓存策略；内存需要内存管理策略；磁盘需要磁盘管理策略。</p></blockquote></li></ol><h3 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h3><p>如同放洗澡水一样，首先检查热水多热，然后检查冷水多冷。然后调节水龙头旋钮，以流出温度合适的水。</p><p>类似的，基于不同类型存储访问速度的巨大差异，需要关注的重点不同。多级存储也给架构设计带来不少问题。</p><p>在大型互联网公司，所有的服务被分为三种类型：</p><ul><li><strong>CPU消耗型</strong>：也称为“计算密集型”，指服务使用CPU完成计算任务，受CPU速度限制。<em>CPU越快，任务处理越快。</em></li><li><strong>内存消耗型</strong>：也称为“内存密集型”，指服务执行任务过程中受内存大小和访问速度限制。<em>内存越大、访问速度越快，任务处理速度越快。</em> 通常为搜索类、缓存类、内存数据库等需求大量内存的服务</li><li><strong>I/O消耗型</strong>：也称为“I/O密集型”，指服务执行任务涉及到大量的网络传输或磁盘I/O，受I/O速度限制。<em>I/O越快，任务处理越快。</em> 一旦发生I/O，服务的工作线程(进程)就会处于等待状态，当I/O结束，数据准备好后，线程(进程)才会继续执行。</li></ul><p>一个服务可以既是“CPU消耗型“，同时也是“内存消耗型”，例如：搜索服务 —— 烧钱玩意儿，腾讯卖掉搜索给搜狗估计也是被烧的肉疼了吧 ：）。</p><p>那为什么如此划分呢？</p><ul><li>一方面，当服务陷入瓶颈的时候能够快速根据类型进行资源预估、调整和性能调优</li><li>另一方面，调度程序可以使用该信息来调度不同类型的服务，使用装包算法（<a href="https://en.wikipedia.org/wiki/Bin_packing_problem" target="_blank" rel="noopener">bin-packingalgorithms</a>）进行最优的混合部署，以达到资源最大利用。<br><img src="/images/high-concurrency-hierarchical-storage/bin-packing.png" alt="bin-packing.png"></li></ul><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>盘点下业界在高并发场景下，使用的存储方案(至少保证数据不丢失)：</p><ol><li>纯内存数据库：以 mongodb 为代表。成本高昂</li><li>内存数据库 + 磁盘数据库：以 Redis/memcached + Mysql/TiDB 为代表。使用起来比较复杂，需要业务自己处理分级存储带来的问题</li><li>高性能高可用分布式数据库：以 megastore（谷歌）/ paxosstore(微信) / Dynamo (亚马逊)，技术门槛比较高，大厂专属</li></ol><p>可以看到绝大部分的互联网公司，还是依靠第二种方案扛住高并发的请求。那么应对高并发的架构中，就不能缺少存储层（也可以称为：持久层，数据访问层），否则业务代码会与存储管理的代码交叉耦合在一起</p><p><img src="/images/high-concurrency-hierarchical-storage/layer-architecture.png" alt="layer-architecture.png"></p><p>使用第二种方案，就免不了缓存的是是非非。既然缓存也是存储层级中的一层，所有的问题也就脱不开分级问题的范畴了，后续详聊。</p><br/><p>参考链接：</p><ul><li><a href="https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean" target="_blank" rel="noopener">What do the terms “CPU bound” and “I/O bound” mean?</a></li><li><a href="https://www.slideshare.net/kubecon/kubecon-eu-2016-a-practical-guide-to-container-scheduling" target="_blank" rel="noopener">A Practical Guide to Container Scheduling</a></li><li><a href="https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html" target="_blank" rel="noopener">Software Architecture Patterns</a></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html">https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;原本想聊下缓存的相关技术，但是纯聊缓存未免眼界太窄，视野太小，既然打算写一个系列，不如就先从底层聊起，然后慢慢铺开。本篇先聊分级存储引入的问
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="总述" scheme="https://www.cyningsun.com/tag/%E6%80%BB%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>译｜How to use Prometheus for anomaly detection in GitLab</title>
    <link href="https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html"/>
    <id>https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.048Z</updated>
    
    <content type="html"><![CDATA[<p>Prometheus 查询语言的最基本功能之一是实时汇总时间序列数据。GitLab基础架构团队的杰出工程师 <code>Andrew Newdigate</code> 认为 Prometheus 查询语言也可以用于检测时间序列数据中的异常。本博客文章解释了异常检测如何与 Prometheus 一起工作，并包括您需要在自己的系统上亲自尝试的代码片段。</p><h3 id="为什么异常检测有效？"><a href="#为什么异常检测有效？" class="headerlink" title="为什么异常检测有效？"></a>为什么异常检测有效？</h3><p>异常检测对 GitLab 非常重要的四个关键原因：</p><ul><li>诊断事件：我们可以快速找出哪些服务执行超出正常范围，并减少检测事件的平均时间（MTTD），从而更快地解决问题。</li><li>检测应用程序性能回归：例如，如果引入 n+1 回归，发现一个服务以很高的速率调用另一个服务，可以迅速找到问题并加以解决。</li><li>识别并解决滥用问题：GitLab 提供免费计算（GitLab CI/CD）和托管（GitLab Pages），会被一小部分用户加以利用。</li><li>安全性：异常检测对于发现 GitLab 时间序列数据中的异常趋势至关重要。</li></ul><p>由于以上以及其他许多原因，Andrew 研究了是否可以仅通过使用 Prometheus 查询和规则对 GitLab 时间序列数据执行异常检测。</p><h3 id="正确的聚合级别是什么？"><a href="#正确的聚合级别是什么？" class="headerlink" title="正确的聚合级别是什么？"></a>正确的聚合级别是什么？</h3><p>首先，时间序列数据必须正确聚合。尽管可以将相同的技术应用到许多其他类型的指标，Andrew 使用了标准计数器 <code>http_requests_total</code> 作为数据源进行演示。</p><pre><code class="hljs js">http_requests_total&#123; job=<span class="hljs-string">"apiserver"</span>, method=<span class="hljs-string">"GET"</span>, controller=<span class="hljs-string">"ProjectsController"</span>, status_code=<span class="hljs-string">"200"</span>, environment=<span class="hljs-string">"prod"</span>&#125;</code></pre><p>上述示例指标有一些额外的维度：<code>method</code>，<code>controller</code>，<code>status_code</code>，<code>environment</code>，如同 Prometheus 添加的维度 <code>instance</code> 和 <code>job</code> 一样。</p><p>接下来，您必须为正在使用的数据选择正确的聚合级别。这有点像“金发姑娘问题”-太多，太少还是恰到好处-但这对于发现异常至关重要。过多地汇总数据，数据将缩减为过小的维度，从而产生两个潜在的问题：</p><ol><li>可能会错过真正的异常，因为聚合隐藏了数据子集中出现的问题。</li><li>如果确实检测到异常，则不对异常进行更多调查，则很难将其归因于系统的特定部分。</li></ol><p>但是，聚合的数据汇太少，最终可能会得到一系列样本量非常小的数据。如此可能导致误报，并可能将真实数据标记为离群值（outliers）。</p><p>恰到好处：我们的经验表明，正确的聚合级别是服务级别，因此我们将 <code>job</code> 和 <code>environment</code> 标签标签包括进来，但删除了其他维度。在本演讲的以下部分中使用的数据聚合包括：<code>job</code>、<code>http requests</code>、<code>五分钟速率</code>(基本上是五分钟窗口中覆盖 <code>job</code> 和 <code>environment</code> 之上的速率)。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m<span class="hljs-symbol">expr:</span> sum without(instance, method, controller, status_code)(rate(http_requests_total[<span class="hljs-number">5</span>m]))<span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="apiserver", environment="prod"&#125;  21321</span><span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="gitserver", environment="prod"&#125;  2212</span><span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="webserver", environment="prod"&#125;  53091</span></code></pre><h3 id="使用-z-score-进行异常检测"><a href="#使用-z-score-进行异常检测" class="headerlink" title="使用 z-score 进行异常检测"></a>使用 z-score 进行异常检测</h3><p>一些统计学的主要原理可以应用于 Prometheus 检测异常。</p><p>如果知道 Prometheus 序列的平均值和标准偏差（σ），则可以使用该系列中的任何样本来计算 <code>z-score</code>。<code>z-score</code> 表示为：与平均值的标准偏差值。因此 z-score 为 0 表示 z-score 与具有正态分布的数据的平均值相同，而 z-score 为 1 则相对于平均值为 1.0σ，依此类推。</p><p>假设基础数据是正态分布的，则 99.7％ 的样本的 z-score 应介于 0 到 3 之间。z-score 距离 0 越远，它越不可能出现。我们将此特性应用于检测 Prometheus 序列中的异常。</p><ol><li>使用样本数量较大的数据计算指标的平均值和标准偏差。在此示例中，我们使用了一周的数据。如果假设我们每分钟评估一次记录规则，那么一周的时间，能获得 10,000 多个样本。<pre><code class="hljs ruby"><span class="hljs-comment"># Long-term average value for the series</span>- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w<span class="hljs-symbol">expr:</span> avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># Long-term standard deviation for the series</span>- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>stddev_over_time_1w<span class="hljs-symbol">expr:</span> stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])</code></pre></li><li>一旦有了聚合的平均值和标准差，就可以计算 Prometheus 查询的 z-score。<pre><code class="hljs sql"><span class="hljs-comment"># Z-Score for aggregation</span>(job:http_requests:rate5m -job:http_requests:rate5m:avg_over_time_1w) /  job:http_requests:rate5m:stddev_over_time_1w</code></pre></li></ol><p>根据正态分布的统计原理，我们可以假设任何超出大约 +3 到 -3 范围的值都是异常。我们可以围绕这一原则建立警报。例如，当聚合超出此范围超过五分钟时，我们将收到警报。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitlab-page-rps.png" alt="gitlab-page-rps.png"><br>GitLab.com 页面服务 48 小时的 RPS， ±3 z-score 区域为绿色</p><p>z-score 在图形上难以解释，因为它们没有度量单位。但是此图表上的异常很容易检测。出现在绿色区域（表示 z-score 在 +3 或 -3 范围内）之外的任何值都是异常。</p><h3 id="如果不是正态分布怎么办？"><a href="#如果不是正态分布怎么办？" class="headerlink" title="如果不是正态分布怎么办？"></a>如果不是正态分布怎么办？</h3><p>但是，请稍等：我们大跃进的假设潜在的聚合具有正态分布。如果我们使用非正态分布的数据计算 z-score，结果将不正确。有许多统计技术可以测试您的数据是否为正态分布，但是最好的选择是测试您的潜在数据的 z-score 约为 +4 到 -4。</p><pre><code class="hljs ruby">( max_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w]) - avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])) / stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># --&gt; &#123;job="apiserver", environment="prod"&#125;  4.01</span><span class="hljs-comment"># --&gt; &#123;job="gitserver", environment="prod"&#125;  3.96</span><span class="hljs-comment"># --&gt; &#123;job="webserver", environment="prod"&#125;  2.96</span>( min_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w]) - avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])) / stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># --&gt; &#123;job="apiserver", environment="prod"&#125;  -3.8</span><span class="hljs-comment"># --&gt; &#123;job="gitserver", environment="prod"&#125;  -4.1</span><span class="hljs-comment"># --&gt; &#123;job="webserver", environment="prod"&#125;  -3.2</span></code></pre><p>两个 Prometheus 查询测试 z-score 的最小和最大值。</p><p>如果结果返回的范围是 +20 到 -20，则尾巴太长，结果将倾斜。还要记住，这需要在聚合而不是非聚合的序列上运行。可能没有正态分布的指标包括诸如错误率、等待时间、队列长度等，但是无论如何，在固定阈值下告警，许多这些指标都趋向于工作的很好。</p><h3 id="使用季节性检测异常"><a href="#使用季节性检测异常" class="headerlink" title="使用季节性检测异常"></a>使用季节性检测异常</h3><p>尽管时间序列数据为正态分布时，计算 z-score 效果很好，但是还有第二种方法可以产生更准确的异常检测结果。季节性是时间序列指标的一个特征，其中该指标会经历定期且可预测的变化，这些变化会在每个周期重复出现。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-weeks.png" alt="gitaly-rps-weeks.png"><br>周一至周日连续四个星期的每秒 Gitaly 请求（RPS）</p><p>该图说明了连续四周的周一到周日的7天中 Gitaly 的 RPS（每秒请求数）速率。七天范围称为“偏移”，表示需要度量的模式。图上的每个星期都有不同的颜色。数据的季节性由图表中所示趋势的一致性表示 —— 每个星期一早晨，RPS 速率都会上升，而在星期五晚上，RPS 速率会逐渐下降，每周如此。</p><p>通过利用时间序列数据中的季节性，可以创建更准确的预测，从而更好地进行异常检测。</p><h3 id="如何利用季节性？"><a href="#如何利用季节性？" class="headerlink" title="如何利用季节性？"></a>如何利用季节性？</h3><p>使用 Prometheus 计算季节性，需要在一些不同的统计原理上迭代。</p><p>在第一次迭代中，我们通过将目前滚动的一周的增长趋势（注：平均值）与前一周的值相加来计算。通过从目前滚动的一周平均值中减去上周的滚动一周平均值来计算增长趋势。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;    <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m offset <span class="hljs-number">1</span>w                     <span class="hljs-comment"># Value from last period</span>    + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w            <span class="hljs-comment"># One-week growth trend</span>    - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w</code></pre><p>第一次迭代有点狭窄；我们使用本周和上周的五分钟窗口来得出我们的预测。</p><p>在第二次迭代中，将上周的四个小时平均值作为平均值，并将其与本周进行比较，以扩大范围。因此，如果要预测一个星期一上午8点的指标值，不是使用一周前的相同五分钟窗口，而是使用前一周早上的上午6点至上午10点的指标平均值。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;    avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h) <span class="hljs-comment"># Rounded value from last period</span>    + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w             <span class="hljs-comment"># Add 1w growth trend</span>    - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w</code></pre><p>在查询中使用166个小时而不是一周，因为要根据一天中的当前时间使用四个小时，因此需要将偏移减少两个小时。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-weeks-prediction.png" alt="gitaly-rps-weeks-prediction.png"><br>两周的 Gitaly 服务 RPS（黄色）vs 预测（蓝色）。</p><p>将实际的 Gitaly RPS（黄色）与 预测（蓝色）进行比较表明，计算相当准确。但是，这种方法有缺陷。因为5月1日是国际劳动节，一个许多国家庆祝的节日，GitLab 的使用量低于平常的星期三。由于增长率是由前一周的使用情况决定的，因此我们对下周（5月8日，星期三）RPS 的预测会比 如果5月1日（星期三）没有假期更低。</p><p>可以通过在5月1日（星期三）之前连续三周（之前的星期三，再之前的星期三和三周之前的星期三）进行三个预测来解决此问题。查询保持不变，但偏移量已调整。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;   quantile(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"1w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">334</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">2</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"2w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">502</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">3</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"3w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)   )   without (offset)</code></pre><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-three-weeks-prediction.png" alt="gitaly-rps-three-weeks-prediction.png"><br>三个星期三的三个预测与实际 5月8日（星期三，国际劳动节之后的一周）的 Gitaly RPS</p><p>在该图上，绘制了5月8日星期三和5月8日之前连续三个星期的三个预测。可以看到其中两个预测是好的，但是5月1日的预测仍远未达到基准。</p><p>而且，我们不需要三个预测，我们想要<strong>一个预测</strong>。取平均值是不可行的，因为它将被倾斜的 5月1日 RPS数据所稀释。相反，我们要计算中位数。Prometheus没有中位数查询，但可以使用分位数聚合来代替中位数。该方法的一个问题是，试图在一个聚合中包括三个系列，而这三个系列实际上在三周内都是相同的系列。换句话说，它们都具有相同的标签，因此连接它们很棘手。为避免混淆，我们创建了一个名为 <code>offset</code> 的标签，并使用 label-replace 函数为三个星期添加offset。接下来，在分位数聚合中，将其去除，以获得了三个中间值。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;   quantile(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"1w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">334</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">2</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"2w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">502</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">3</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"3w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)   )   without (offset)</code></pre><p>现在，从三个聚合系列中得出中值的预测更加准确。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-median-weeks-prediction.png" alt="gitaly-rps-median-weeks-prediction.png"><br>中位数预测与实际 Gitaly RPS 的比较，5月8日（星期三，国际劳动节之后的一周）</p><h3 id="怎么知道预测是真正准确的？"><a href="#怎么知道预测是真正准确的？" class="headerlink" title="怎么知道预测是真正准确的？"></a>怎么知道预测是真正准确的？</h3><p>为了测试预测的准确性，可以返回 z-score。可以使用 z-score 来测量样本与标准偏差预测值之间的差距。偏离预测的标准偏差越多，则特定值是异常可能性就越大。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-normal-range-prediction.png" alt="gitaly-rps-normal-range-prediction.png"><br>Gitaly 服务的预测正常范围 ±1.5σ</p><p>我们可以更新 Grafana 图表以使用季节性预测而不是每周滚动平均值。一天中特定时间的正常范围以绿色阴影显示。任何落在绿色阴影区域之外的东西都被认为是异常值。在这种情况下，离群值发生在周日下午，此时我们的云提供商遇到了一些网络问题。在我们的预测的任一侧使用±2σ的边界是确定季节性预测的异常值的一种很好的方法。</p><h3 id="如何使用Prometheus设置警报"><a href="#如何使用Prometheus设置警报" class="headerlink" title="如何使用Prometheus设置警报"></a>如何使用Prometheus设置警报</h3><p>如果要为异常事件设置警报，可以对 Prometheus 应用一个非常简单的规则，该规则检查指标的 z-score 是否在标准偏差 +2 或 -2 之间。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">alert:</span> RequestRateOutsideNormalRange  <span class="hljs-symbol">expr:</span> &gt;   abs(     (       <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction     ) / <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>stddev_over_time_1w   ) &gt; <span class="hljs-number">2</span>  <span class="hljs-symbol">for:</span> <span class="hljs-number">10</span>m  <span class="hljs-symbol">labels:</span>    <span class="hljs-symbol">severity:</span> warning  <span class="hljs-symbol">annotations:</span>    <span class="hljs-symbol">summary:</span> Requests <span class="hljs-keyword">for</span> job &#123;&#123; $labels.job &#125;&#125; are outside of expected operating parameters</code></pre><p>在 GitLab，我们使用了自定义路由规则，该规则会在检测到任何异常时 pings Slack，但不会寻呼值班的支持人员。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Prometheus 可用于某些类型的异常检测</li><li>正确级别的数据聚合是异常检测的关键</li><li>如果数据具有正态分布，则 z-score 是一种有效的方法</li><li>季节性指标可以为异常检测提供出色的结果</li></ol><p>视频链接：<a href="https://vimeo.com/341141334" target="_blank" rel="noopener">https://vimeo.com/341141334</a><br>原文链接：<a href="https://about.gitlab.com/blog/2019/07/23/anomaly-detection-using-prometheus/" target="_blank" rel="noopener">https://about.gitlab.com/blog/2019/07/23/anomaly-detection-using-prometheus/</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html">https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Prometheus 查询语言的最基本功能之一是实时汇总时间序列数据。GitLab基础架构团队的杰出工程师 &lt;code&gt;Andrew Newdigate&lt;/code&gt; 认为 Prometheus 查询语言也可以用于检测时间序列数据中的异常。本博客文章解释了异常检测如何与 P
      
    
    </summary>
    
    
      <category term="SRE" scheme="https://www.cyningsun.com/category/SRE/"/>
    
    
      <category term="Anomaly detection" scheme="https://www.cyningsun.com/tag/Anomaly-detection/"/>
    
  </entry>
  
  <entry>
    <title>深度探索 Go 对象模型</title>
    <link href="https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html"/>
    <id>https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html</id>
    <published>2020-01-11T16:00:00.000Z</published>
    <updated>2020-09-04T16:11:04.047Z</updated>
    
    <content type="html"><![CDATA[<p>了解一门语言的高级特性，仅仅从浮于表面，是无法把握住语言的精髓的。学习过 C++ 的高阶开发者，一定读过神书《Inside The C++ Object Model》，本文的目标是一样的：通过对象模型，掌握 Go 语言的底层机制，从更深层次解释语言特性。</p><h3 id="编译与执行"><a href="#编译与执行" class="headerlink" title="编译与执行"></a>编译与执行</h3><p>众所周知，Go 源码并不能直接运行，所有代码必须一行行，通过“编译”——“汇编”——“链接” 阶段 转化为低级的机器语言指令，即可执行程序。</p><p><img src="/images/go-object-model/compile.png" alt="compile.png"></p><p>“汇编”和“链接”阶段各种语言并无区别，所以一般通过“编译”和“执行”阶段来支持各种语言特性。对于 Go 语言，执行过程并无法直接修改执行指令，因此所有语言特性都是“编译”相关的。理解这一点很重要，因为下面依赖“编译”的产物 <strong>汇编代码</strong> 来解读对象模型。</p><h3 id="什么是对象模型？"><a href="#什么是对象模型？" class="headerlink" title="什么是对象模型？"></a>什么是对象模型？</h3><p>何为 Go 对象模型？ Go 对象模型可以概括为以下两部分：</p><ol><li>支持面向对象程序设计的部分<blockquote><ul><li>封装</li><li>继承</li><li>多态</li></ul></blockquote></li><li>各种特性的底层实现机制<blockquote><ul><li>反射</li></ul></blockquote></li></ol><p>下面分别从 struct 和 interface 来解释模型如何支持以上两部分。</p><h3 id="Struct-语意学"><a href="#Struct-语意学" class="headerlink" title="Struct 语意学"></a>Struct 语意学</h3><p><img src="/images/go-object-model/struct.png" alt="struct.png"></p><p>面向对象编程，把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数，前者为成员变量，后者为成员函数。所以研究对象需要分别从成员变量和成员函数入手。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>以下有三段程序：</p><pre><code class="hljs go"><span class="hljs-comment">// First: global varible</span><span class="hljs-keyword">var</span> (   X,Y,Z <span class="hljs-keyword">float32</span>)<span class="hljs-comment">// Second: simple type</span><span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-comment">// Third: inherit type</span><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;</code></pre><p>从风格来看，三段程序截然不同。有许多令人信服的讨论告诉我们，为什么“数据封装”（Second &amp; Third）要比使用“全局变量”好。但，从程序员的角度看，会有几个疑问：</p><blockquote><ol><li>“数据封装” 之后，内存成本增加了多少？</li><li>“数据封装” 之后，在执行过程中，变量的存储效率是否降低了？</li></ol></blockquote><h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><p>先看内存变化。了解内存变化最好的办法就是通过代码打印对象的内存大小，先看全局变量大小</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> (X, Y, Z <span class="hljs-keyword">float32</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"X size:%v, Y size:%v, Z size:%v\n"</span>, unsafe.Sizeof(X), unsafe.Sizeof(Y), unsafe.Sizeof(Z))fmt.Printf(<span class="hljs-string">"X addr:%v, Y addr:%v, Z addr:%v\n"</span>, &amp;X, &amp;Y, &amp;Z)&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go run variable.goX size:4, Y size:4, Z size:4X addr:0x118ee88, Y addr:0x118ee8c, Z addr:0x118ee90</code></pre><p>可以看到，X、Y、Z三个字段大小均为4字节，且三个字段内存地址顺序排列。</p><p>再看第二段代码的输出</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLayout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;p := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v, align:%v\n"</span>, unsafe.Sizeof(p), unsafe.Alignof(p))typ := reflect.TypeOf(p)fmt.Printf(<span class="hljs-string">"Struct:%v is %d bytes long\n"</span>, typ.Name(), typ.Size())fmt.Printf(<span class="hljs-string">"X at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.X), unsafe.Sizeof(p.X))fmt.Printf(<span class="hljs-string">"Y at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Y), unsafe.Sizeof(p.Y))fmt.Printf(<span class="hljs-string">"Z at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Z), unsafe.Sizeof(p.Z))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestLayout=== RUN   TestLayoutpoint3d size:12, align:4Struct:point3d is 12 bytes longX at offset 0, size=4Y at offset 4, size=4Z at offset 8, size=4</code></pre><p>可以看到，X、Y、Z三个字段大小一样为4字节，内存排列也与上一个版本一样。</p><p>继续，第三段代码</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLayout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;p := point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v, align:%v\n"</span>, unsafe.Sizeof(p), unsafe.Alignof(p))typ := reflect.TypeOf(p)fmt.Printf(<span class="hljs-string">"Struct:%v is %d bytes long\n"</span>, typ.Name(), typ.Size())fmt.Printf(<span class="hljs-string">"X at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.X), unsafe.Sizeof(p.X))fmt.Printf(<span class="hljs-string">"Y at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Y), unsafe.Sizeof(p.Y))fmt.Printf(<span class="hljs-string">"Z at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Z), unsafe.Sizeof(p.Z))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestLayout=== RUN   TestLayoutpoint3d size:12, align:4Struct:point3d is 12 bytes longX at offset 0, size=4Y at offset 4, size=4Z at offset 8, size=4</code></pre><p>可以看到，X、Y、Z三个字段大小一样为4字节，内存排列也与之前两个版本一样。</p><p>综上所述，我们可以看到，无论是否封装，还是多深的继承层次，对成员变量的内存布局都并无影响，均按照字段定义的顺序排列（不考虑内存对齐的情况）。即内存布局类似如下：</p><p><img src="/images/go-object-model/memory-offset.png" alt="memory-offset.png"></p><h5 id="变量存取"><a href="#变量存取" class="headerlink" title="变量存取"></a>变量存取</h5><p>成员变量有两种读取方式，既可以通过对象读取，也可以通过对象的指针读取。两种读取方式与直接变量读取会有什么不同么？使用一段代码再看下：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> (w <span class="hljs-keyword">float32</span>)point := point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L25</span>p := &amp;point  <span class="hljs-comment">// L26</span>w = point.Y  <span class="hljs-comment">// L27</span>fmt.Printf(<span class="hljs-string">"w:%f\n"</span>, w)w = p.Y     <span class="hljs-comment">// L29</span>fmt.Printf(<span class="hljs-string">"w:%f\n"</span>, w)&#125;</code></pre><p>还记得之前提过的“编译”阶段么？我们使用 go tool 可以查看源代码汇编之后的代码</p><pre><code class="hljs x86asm"><span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948d8</span>f30f11442444<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948de</span>f30f11442448<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948e4</span>f30f1144244c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x4c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948ea</span>f30f10055ab50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948f2</span>f30f11442444<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948f8</span>f30f100550b50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094900</span>f30f11442448<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094906</span>f30f100546b50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x109490e</span>f30f1144244c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x4c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">26</span><span class="hljs-number">0x1094914</span>488d442444LEAQ <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">data_access.go:</span><span class="hljs-number">26</span><span class="hljs-number">0x1094919</span><span class="hljs-number">4889442450</span><span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">27</span><span class="hljs-number">0x109491e</span>f30f10442448<span class="hljs-keyword">MOVSS</span> <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>), X0// 读取 Y 到寄存器 X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">27</span><span class="hljs-number">0x1094924</span>f30f11442440<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x40</span>(<span class="hljs-built_in">SP</span>)// 赋值 寄存器 X0 给 w...<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949c7</span>488b442450<span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// 读取 对象地址 到寄存器 <span class="hljs-built_in">AX</span> <span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949cc</span><span class="hljs-number">8400</span>TESTB <span class="hljs-built_in">AL</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949ce</span>f30f104004<span class="hljs-keyword">MOVSS</span> <span class="hljs-number">0x4</span>(<span class="hljs-built_in">AX</span>), X0// 从对象起始地址偏移<span class="hljs-number">4</span>字节读取数据到寄存器 X0 <span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949d3</span>f30f11442440<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x40</span>(<span class="hljs-built_in">SP</span>)// 赋值 寄存器 X0 给 w</code></pre><p>可以看到，每个成员变量的偏移量在编译时即可获知，不管其有多么复杂的继承，都是一样的。通过对象存取一个data member，其效率和存取一个非成员变量是一样的。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>前面的例子提过，对象的总大小刚好等于所有的成员变量之和，也就意味着成员函数并不占用对象的内存大小。那成员函数的调用是怎么实现的呢？我们通过一段代码看下</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *point3d)</span> <span class="hljs-title">Println</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"%v,%v,%v\n"</span>, p.X, p.Y, p.Z)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;p := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L14</span>p.Println()                   <span class="hljs-comment">// L15</span>&#125;</code></pre><p>同样使用 go tool获取对应的汇编代码</p><pre><code class="hljs x86asm"><span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a7d</span>0f57c0<span class="hljs-keyword">XORPS</span> X0, X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a80</span>f30f1144240c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a86</span>f30f11442410<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x10</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a8c</span>f30f11442414<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x14</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a92</span>f30f100592b30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a9a</span>f30f1144240c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aa0</span>f30f100588b30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aa8</span>f30f11442410<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x10</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aae</span>f30f10057eb30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094ab6</span>f30f11442414<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x14</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094abc</span>488d44240cLEAQ <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span> //将对象 q 的起始地址保存到寄存器<span class="hljs-built_in">AX</span><span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094ac1</span><span class="hljs-number">48890424</span><span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)  //将对象 q 的起始地址 压栈<span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094ac5</span>e8d6fdffff<span class="hljs-keyword">CALL</span> main.(*point3d).Println(SB)  // 调用 struct point 的 Println() 函数</code></pre><p>可以看到成员函数的调用都是先把参数压栈，然后调用对应的的函数。可见，成员函数与普通的函数调用并无不同。那么函数的内存在哪里呢？</p><p>还记得进程的内存分布么？</p><p><img src="/images/go-object-model/process-memory.png" alt="process-memory.png"></p><p>没错，所有的函数都在进程的代码段（Text Segment）</p><h3 id="Interface-语意学"><a href="#Interface-语意学" class="headerlink" title="Interface 语意学"></a>Interface 语意学</h3><p>第一部分讲了，封装和继承的影响，剩下这部分会讲清楚 Go 如何使用 interface 实现<code>多态</code>和<code>反射</code>。其中interface又有两种形式，一种是有函数的非空interface，一种是空的interface（interface{}）。话不多说，直接上代码，看下这两种类型的interface的变量在内存大小上有何区别：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">interface</span> &#123;Println()&#125;<span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPolymorphism</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> (p Point)p = &amp;point&#123;X: <span class="hljs-number">1</span>&#125;fmt.Printf(<span class="hljs-string">"point size:%v\n\n"</span>, unsafe.Sizeof(p))p = &amp;point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;fmt.Printf(<span class="hljs-string">"point2d size:%v\n\n"</span>, unsafe.Sizeof(p))p = &amp;point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v\n\n"</span>, unsafe.Sizeof(p))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestPolymorphism=== RUN   TestPolymorphismp size:16, nilP size:16p size:16, nilP size:16p size:16, nilP size:16</code></pre><p>可以看到两种类型的interface 变量大小并无不同，均为16字节。可以明确一点：interface 变量中存储的并非对象的指针，而是特殊的定义类型的变量。那么 interface 是怎么支持<code>多态</code>和<code>反射</code>的呢？</p><p>通过 <code>reflect</code> 包，我们找到了答案。原来，针对以上两种类型的interface， Go 语言底层定义了两个结构分别为 iface 和 eface。两者实现是类似的，以下我们仅针对非空interface进行分析</p><h4 id="interface-底层"><a href="#interface-底层" class="headerlink" title="interface 底层"></a>interface 底层</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;    tab  *itab          <span class="hljs-comment">// 类型信息</span>    data unsafe.Pointer  <span class="hljs-comment">// 接口指向对象的指针</span>&#125;<span class="hljs-comment">// 类型信息</span><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;    inter  *interfacetype    <span class="hljs-comment">// 接口的类型信息</span>    _type  *_type           <span class="hljs-comment">// 接口指向对象的类型信息</span>hash  <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// copy of _type.hash. Used for type switches.</span>_     [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>    fun    [<span class="hljs-number">1</span>]<span class="hljs-keyword">uintptr</span>       <span class="hljs-comment">// 接口方法实现列表，即函数地址列表，按字典序排序</span>&#125;<span class="hljs-comment">// 接口类型信息</span><span class="hljs-keyword">type</span> interfacetype <span class="hljs-keyword">struct</span> &#123;   typ     _type   pkgpath name   mhdr    []imethod      <span class="hljs-comment">// 接口方法声明列表，按字典序排序</span>&#125;</code></pre><p>通过代码，可以看到，iface 类型包含两个指针，刚好为16字节（64位机器）。iface 不但包含了<code>指向对象</code>、<code>指向对象的类型</code>，还包含了<code>接口类型</code>。如此</p><ol><li>iface 就可以在其中扮演粘结剂的角色，通过 reflect 包在对象、接口、类型之间进行转换了。</li><li>iface 的变量可以在<code>编译</code>阶段，在变量赋值处，增加拷贝指向对象（父类或者子类）的类型信息的指令，就可以在运行期完成多态的支持了</li></ol><p><img src="/images/go-object-model/interface.png" alt="interface.png"></p><h4 id="理论验证"><a href="#理论验证" class="headerlink" title="理论验证"></a>理论验证</h4><p>下面我们还是通过测试代码来验证我们的理论，我们自己定义底层的相关类型，然后通过强制类型转换，来尝试解析interface变量中的数据：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Iface <span class="hljs-keyword">struct</span> &#123;Tab *ItabData unsafe.Pointer&#125;<span class="hljs-keyword">type</span> Itab <span class="hljs-keyword">struct</span> &#123;Inter <span class="hljs-keyword">uintptr</span>Type <span class="hljs-keyword">uintptr</span>Hash <span class="hljs-keyword">uint32</span>_ [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>Fun [<span class="hljs-number">1</span>]<span class="hljs-keyword">uintptr</span>&#125;<span class="hljs-keyword">type</span> Eface <span class="hljs-keyword">struct</span> &#123;Type <span class="hljs-keyword">uintptr</span>Data unsafe.Pointer&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInterface</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> (p    PointnilP <span class="hljs-keyword">interface</span>&#123;&#125;)point := &amp;point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;nilP = pointfmt.Printf(<span class="hljs-string">"eface size:%v\n"</span>, unsafe.Sizeof(nilP))eface := (*face.Eface)(unsafe.Pointer(&amp;nilP))spew.Dump(eface.Type)spew.Dump(eface.Data)fmt.Printf(<span class="hljs-string">"eface offset: eface._type = %v, eface.data = %v\n\n"</span>,unsafe.Offsetof(eface.Type), unsafe.Offsetof(eface.Data))p = pointfmt.Printf(<span class="hljs-string">"point size:%v\n"</span>, unsafe.Sizeof(p))iface := (*face.Iface)(unsafe.Pointer(&amp;p))spew.Dump(iface.Tab)spew.Dump(iface.Data)fmt.Printf(<span class="hljs-string">"Iface offset: iface.tab = %v, iface.data = %v\n\n"</span>,unsafe.Offsetof(iface.Tab), unsafe.Offsetof(iface.Data))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestInterface=== RUN   TestInterfaceeface size:16(uintptr) 0x111f2c0(unsafe.Pointer) 0xc00008e250eface offset: eface._type = 0, eface.data = 8point size:16(*face.Itab)(0x116ec40)(&#123; Inter: (uintptr) 0x1122680, Type: (uintptr) 0x111f2c0, Hash: (uint32) 960374823, _: ([4]uint8) (len=4 <span class="hljs-built_in">cap</span>=4) &#123;  00000000  00 00 00 00                                       |....| &#125;, Fun: ([1]uintptr) (len=1 <span class="hljs-built_in">cap</span>=1) &#123;  (uintptr) 0x10fce20 &#125;&#125;)(unsafe.Pointer) 0xc00008e250Iface offset: iface.tab = 0, iface.data = 8</code></pre><p>下面我们再通过汇编代码看下，赋值操作做了什么？</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">interface</span> &#123;Println()&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *point3d)</span> <span class="hljs-title">Println</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"%v,%v,%v\n"</span>, p.X, p.Y, p.Z)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;point := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L18</span><span class="hljs-keyword">var</span> (nilP <span class="hljs-keyword">interface</span>&#123;&#125;   <span class="hljs-comment">// L20</span>p    Point        <span class="hljs-comment">// L21</span>)nilP = &amp;point         <span class="hljs-comment">// L23</span>p = &amp;point            <span class="hljs-comment">// L24</span>fmt.Println(nilP, p) &#125;</code></pre><p>通过 go tool 查看汇编代码如下：</p><pre><code class="hljs x86asm">TEXT main<span class="hljs-number">.</span>main(SB) /Users/cyningsun/Documents/go/src/github<span class="hljs-number">.</span>com/cyningsun/go-<span class="hljs-keyword">test</span>/<span class="hljs-number">20200102</span>-inside-golang-object-model/main/build<span class="hljs-number">.</span>go<span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094de0</span>65488b0c2530000000      <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">GS</span>:<span class="hljs-number">0x30</span>, <span class="hljs-built_in">CX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094de9</span>488d4424b0              LEAQ -<span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094dee</span>483b4110                CMPQ <span class="hljs-number">0x10</span>(<span class="hljs-built_in">CX</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094df2</span>0f86b9010000            <span class="hljs-keyword">JBE</span> <span class="hljs-number">0x1094fb1</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094df8</span>4881ecd0000000          SUBQ <span class="hljs-number">$0</span>xd0, <span class="hljs-built_in">SP</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094dff</span>4889ac24c8000000        <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">BP</span>, <span class="hljs-number">0xc8</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094e07</span>488dac24c8000000        LEAQ <span class="hljs-number">0xc8</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">BP</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e0f</span>488d05ea1e0200          LEAQ type.*+<span class="hljs-number">137216</span>(SB), <span class="hljs-built_in">AX</span>   // point := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e16</span><span class="hljs-number">48890424</span>                <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e1a</span>e81160f7ff              <span class="hljs-keyword">CALL</span> runtime<span class="hljs-number">.</span>newobject(SB)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e1f</span>488b442408              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x8</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e24</span><span class="hljs-number">4889442458</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e29</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e2c</span>f30f11442434            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x34</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e32</span>f30f11442438            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x38</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e38</span>f30f1144243c            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x3c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e3e</span>f30f1005a6b80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e46</span>f30f11442434            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x34</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e4c</span>f30f100d9cb80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X1<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e54</span>f30f114c2438            <span class="hljs-keyword">MOVSS</span> X1, <span class="hljs-number">0x38</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e5a</span>f30f101592b80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X2<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e62</span>f30f1154243c            <span class="hljs-keyword">MOVSS</span> X2, <span class="hljs-number">0x3c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e68</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e6d</span>f30f1100                <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e71</span>f30f114804              <span class="hljs-keyword">MOVSS</span> X1, <span class="hljs-number">0x4</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e76</span>f30f115008              <span class="hljs-keyword">MOVSS</span> X2, <span class="hljs-number">0x8</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">20</span><span class="hljs-number">0x1094e7b</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0 // nilP interface&#123;&#125;<span class="hljs-symbol">  build.go:</span><span class="hljs-number">20</span><span class="hljs-number">0x1094e7e</span>0f11442470              <span class="hljs-keyword">MOVUPS</span> X0, <span class="hljs-number">0x70</span>(<span class="hljs-built_in">SP</span>)// nilP 开始地址为<span class="hljs-number">0x70</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">21</span><span class="hljs-number">0x1094e83</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0 // p Point<span class="hljs-symbol">  build.go:</span><span class="hljs-number">21</span><span class="hljs-number">0x1094e86</span>0f11442460              <span class="hljs-keyword">MOVUPS</span> X0, <span class="hljs-number">0x60</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e8b</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// nilP = &amp;point  ；<span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>) 为 point 的地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e90</span><span class="hljs-number">4889442448</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>) // <span class="hljs-built_in">SP</span> 指向 point 地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e95</span>488d0da4860100          LEAQ type.*+<span class="hljs-number">98368</span>(SB), <span class="hljs-built_in">CX</span> // ；从内存加载 Point类型地址 到 <span class="hljs-built_in">CX</span> 寄存器<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e9c</span>48894c2470              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">CX</span>, <span class="hljs-number">0x70</span>(<span class="hljs-built_in">SP</span>) // ；将 Point类型地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x70</span>（即eface<span class="hljs-number">.</span>_type）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094ea1</span><span class="hljs-number">4889442478</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x78</span>(<span class="hljs-built_in">SP</span>) // ；将 point 对象地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x78</span>（即eface<span class="hljs-number">.</span>data）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094ea6</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// p = &amp;point<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eab</span><span class="hljs-number">4889442448</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)// ；<span class="hljs-built_in">SP</span> 指向 point 地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eb0</span>488d0d09d50400          LEAQ go<span class="hljs-number">.</span>itab.*main<span class="hljs-number">.</span>point3d,main<span class="hljs-number">.</span>Point(SB), <span class="hljs-built_in">CX</span>// ；从内存加载 Point类型 itab 地址 到 <span class="hljs-built_in">CX</span> 寄存器<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eb7</span>48894c2460              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">CX</span>, <span class="hljs-number">0x60</span>(<span class="hljs-built_in">SP</span>)// ；将 Point类型地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x70</span>（即iface<span class="hljs-number">.</span>tab）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094ebc</span><span class="hljs-number">4889442468</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x68</span>(<span class="hljs-built_in">SP</span>)// ；将 point 对象地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x78</span>（即iface<span class="hljs-number">.</span>data）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094ec1</span>488b442468              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x68</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// fmt<span class="hljs-number">.</span>Println(nilP, p)  ...</code></pre><p>事实正如理论一般，在<code>编译</code>阶段，赋值命令被转化为类型信息和对象指针的拷贝，保存下来执行期转换所需要的一切信息。</p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>从底层代码和汇编出发，分析 struct 和 interface 的 对象模型，理清了Go 语言高级特性的底层机制。再去学习反射等表层细节，事半功倍。</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/qcrao-2018/p/11124360.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/11124360.html</a></li><li><a href="https://yougg.github.io/2017/03/27/%E7%90%86%E8%A7%A3go%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B1interface%E5%BA%95%E5%B1%82%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">https://yougg.github.io/2017/03/27/理解go语言模型1interface底层详解/</a></li><li><a href="https://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">https://wudaijun.com/2018/01/go-interface-implement/</a></li><li><a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/8948153.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsgxeva/p/8948153.html</a></li></ul><p><em>源代码：<a href="https://github.com/cyningsun/go-test" target="_blank" rel="noopener">https://github.com/cyningsun/go-test</a></em></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html">https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解一门语言的高级特性，仅仅从浮于表面，是无法把握住语言的精髓的。学习过 C++ 的高阶开发者，一定读过神书《Inside The C++ Object Model》，本文的目标是一样的：通过对象模型，掌握 Go 语言的底层机制，从更深层次解释语言特性。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Object model" scheme="https://www.cyningsun.com/tag/Object-model/"/>
    
  </entry>
  
</feed>
